# Ретест 2025-11-16 — диалог зависает после self-test

## Внешние шаги и результаты
1. **Сброс кэша известных пользователей** — `known-users/clear` вернул `{ok:true, cleared:0}`.
2. **/healthz** — ответ `{ "status": "ok" }` (воркер доступен).
3. **/admin/selftest?q=bindings** — `telegramOk:true`, `openAiOk:false`, ошибка `"openai: missing diagnostic marker"`, latency OpenAI ≈4.9s; в телеграм-чате администратора зафиксированы два сообщения «Self-test ping».
4. **/admin/selftest?q=telegram.getMe** — подтверждает `telegramOk:true`, но `openAiOk:false` c той же ошибкой.
5. **/admin/selftest?q=utm** — все проверки `ok`, `utmDegraded:false`.
6. После пингов бот перестал отвечать администратору: в чате нет typing/ответов на команды.
7. **Боевой диплинк обычного пользователя** — старт бота без ответа.
8. **Экспорт UTM (админ)** — команда выполняется, но бот продолжает молчать у администратора.
9. **/admin/selftest?q=send-admin&chatId=136326606** — `telegramOk:false`, `openAiOk:false`, ошибка `"telegram: Bad Request: chat not found"`.

## Симптомы ретеста
- Self-test отправляет сообщения администратору, но основной диалог после пинга «замолкает».
- Все AI-проверки возвращают `missing diagnostic marker` (OpenAI-контур не подтверждён).
- Telegram send-admin возвращает 400, указывая на некорректный `chat_id`.
- Обычные пользователи также не получают ответов.

## Карта диагностики
- **Сервисная оболочка**: `/healthz` стабильно `ok` → воркер активен.
- **DIAG Bindings**: Telegram доступен, секреты смонтированы; OpenAI не подтверждён (нет маркера).
- **DIAG Telegram**: `getMe` проходит, значит HTTP-токен валиден, но `send-admin` падает по 400 → проблема в ID/сообщении.
- **DIAG UTM**: запись/чтение UTM не деградируют.
- **Поведенческие наблюдения**: двойной «Self-test ping» совпадает с потерей отклика → возможно, тест отправляет запрос, который повреждает кеш/контекст пользователя.

## Гипотезы
1. **H1 — потеря точности `chat_id` после self-test**: self-test отправляет ответ с обрезанным ID → последующие сообщения для администратора (и потенциально других пользователей) получают неправильный `chat_id`, что приводит к 400 и остановке диалога.
2. **H2 — кэш известных пользователей сохраняет повреждённый ID**: после self-test в `knownUsers` попадает обрезанный идентификатор, который переиспользуется для всех команд, пока не выполнен сброс.
3. **H3 — OpenAI fallback блокирует выдачу**: `missing diagnostic marker` переводит пайплайн в защитный режим, и при одновременной ошибке Telegram диалог переходит в «молчание».
4. **H4 — отправка двух сообщений self-test** вызывает гонку: параллельные запросы модифицируют общее состояние (`knownUsers`, rate limiter) и один из потоков завершает сценарий с 400, что оставляет пользователя без ответа.

## Диагностические задачи (one-click ready)

:::task-stub{title="Переподтвердить self-test без порчи chat_id"}
1. Локально воспроизвести self-test (`bindings`, `telegram.getMe`, `send-admin`) с инструментированным логированием `chatId` до и после `toIdString`.
2. Проверить, фиксируется ли потеря точности в `apps/worker-main/http/telegram-webhook.ts` и вспомогательных хелперах.
3. Обновить памятку с логами, приложить вывод и уточнить, какой шаг портит ID.
:::

:::task-stub{title="Проверить кэш известных пользователей"}
1. В журнале запросов удостовериться, что self-test пишет ID в `knownUsers` и какие значения сохраняются.
2. Если ID обрезан, зафиксировать место записи (`apps/worker-main/features/known-users/*`).
3. Подготовить фиксацию для очистки/валидатора ID в кэше.
:::

:::task-stub{title="Диагностировать OpenAI diagnostic marker"}
1. Проследить, какие параметры self-test отправляет в OpenAI и что ожидает в ответе.
2. Проверить конфигурацию `OPENAI_PROMPT_ID`/маркера в `bindings` и в коде self-test.
3. Подготовить рекомендации по фиксации или отключению маркера на время восстановления Telegram-пайплайна.
:::

:::task-stub{title="Исключить гонку двойного self-test ping"}
1. Проанализировать логи воркера в момент двойного сообщения (в `logs/`/`snapshot/`).
2. Проверить, выполняет ли self-test несколько параллельных `sendTyping/sendMessage` и как они влияют на rate-limit и состояние.
3. Подготовить предложение по сериализации self-test или разделению контекстов.
:::

## Следующие шаги
- Обновить issue [2025-11-16-telegram-id-lossless-parser](../issues/2025-11-16-telegram-id-lossless-parser.md) ссылкой на ретест.
- После подтверждения гипотез запланировать фиксы в RoadMap.
