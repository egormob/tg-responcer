# Ретест 2025-11-16 — диалог зависает после self-test

## Резюме ретеста
- **Статус:** повторная проверка подтверждает воспроизводимость обрыва диалога после self-test.
- **Основное проявление:** после двух сообщений «Self-test ping» бот перестаёт отвечать как администраторам, так и обычным пользователям.
- **Блокирующий фактор:** `chat_id` искажается между приёмом апдейта и отправкой ответа; `send-admin` возвращает 400.

## Ключевые выводы
1. Lossless-парсинг `chat_id` по-прежнему отсутствует: наблюдается рассинхрон `136236606` (рабочий ID) ↔ `136326606` (ошибка 400).
2. Вебхук-ветка завершается до `sendMessage`: Cloudflare фиксирует только входящие `telegram.message/typing_update` без исходящих отправок.
3. DIAG-контур жив (`telegramOk:true`), но OpenAI-конфигурация остаётся деградированной (`missing diagnostic marker`).
4. Кэш `knownUsers` не очищается: `cleared:0`, что указывает на другой сегмент или отсутствие записи ID.

## Требуемые логи
| Шаг | chat_id_raw | chat_id_used | Маршрут | HTTP код | Комментарий |
| --- | --- | --- | --- | --- | --- |
| `/admin/selftest?q=bindings` | `136236606` | `136236606` | `diag.bindings` | 200 | Базовая проверка доступности Telegram/секретов.
| `/admin/selftest?q=send-admin&chatId=136326606` | `136236606` | `136326606` | `diag.send-admin` | 400 | Telegram возвращает `Bad Request: chat not found`.
| Диплинк обычного пользователя | `136236606` | — (ответ не отправлен) | `webhook.user` | — | После self-test бот не пишет и не показывает typing.

## Внешние шаги и результаты
1. **Сброс кэша известных пользователей** — `known-users/clear` вернул `{ok:true, cleared:0}`.
2. **/healthz** — ответ `{ "status": "ok" }` (воркер доступен).
3. **/admin/selftest?q=bindings** — `telegramOk:true`, `openAiOk:false`, ошибка `"openai: missing diagnostic marker"`, latency OpenAI ≈4.9s; в телеграм-чате администратора зафиксированы два сообщения «Self-test ping».
4. **/admin/selftest?q=telegram.getMe** — подтверждает `telegramOk:true`, но `openAiOk:false` c той же ошибкой.
5. **/admin/selftest?q=utm** — все проверки `ok`, `utmDegraded:false`.
6. После пингов бот перестал отвечать администратору: в чате нет typing/ответов на команды.
7. **Боевой диплинк обычного пользователя** — старт бота без ответа.
8. **Экспорт UTM (админ)** — команда выполняется, но бот продолжает молчать у администратора.
9. **/admin/selftest?q=send-admin&chatId=136326606** — `telegramOk:false`, `openAiOk:false`, ошибка `"telegram: Bad Request: chat not found"`.

### Дополнительные внешние тесты и диагностика
- Повторный прогон последовательности self-test «bindings → telegram.getMe → utm → send-admin» подтверждает, что DIAG-контуры живы, однако webhook-ответы по-прежнему не отправляются.
- Повторное открытие диплинка обычным пользователем фиксирует отсутствие `typing` и текстового ответа.
- Latency `openAiLatencyMs` держится в диапазоне 2.5–4.9 с, `telegramLatencyMs` — до 160 мс.
- Self-test `send-admin` возвращает `chatIdSource:"query"` и ошибку 400, что говорит о подмене идентификатора вне payload обновления.

### Cloudflare Workers — лог запросов
Дамп (ручной конспект с дашборда Cloudflare) фиксирует последовательность POST-запросов на воркер в момент ретеста: воркер принимает webhook и typing-update события, но после typing не наблюдается `sendMessage`.

| Timestamp (UTC) | Метод/путь | Тег события | Комментарий |
| --- | --- | --- | --- |
| 2025-11-16 13:52:48.915 | `POST /webhook/telegram` | `telegram.message` | входящее сообщение перед потерей отклика |
| 2025-11-16 13:52:48.242 | `POST /webhook/telegram` | `telegram.typing_update` | typing-update, зафиксированный воркером |
| 2025-11-16 13:52:47.547 | `POST /webhook/telegram` | `telegram.message` | очередной update пользователя |
| 2025-11-16 13:52:46.981 | `POST /webhook/telegram` | `telegram.typing_update` | typing self-test перед обрывом |

В выбранном окне наблюдения нет других событий, объясняющих «тишину».

## Симптомы ретеста
- Self-test отправляет сообщения администратору, но основной диалог после пинга «замолкает».
- Все AI-проверки возвращают `missing diagnostic marker` (OpenAI-контур не подтверждён).
- Telegram send-admin возвращает 400, указывая на некорректный `chat_id`.
- Обычные пользователи также не получают ответов.
- Cloudflare подтверждает получение webhook typing/message без последующего `sendMessage`.

## Карта диагностики
- **Сервисная оболочка**: `/healthz` стабильно `ok` → воркер активен.
- **DIAG Bindings**: Telegram доступен, секреты смонтированы; OpenAI не подтверждён (нет маркера).
- **DIAG Telegram**: `getMe` проходит, значит HTTP-токен валиден, но `send-admin` падает по 400 → проблема в ID/сообщении.
- **DIAG UTM**: запись/чтение UTM не деградируют.
- **Поведенческие наблюдения**: двойной «Self-test ping» совпадает с потерей отклика → возможно, тест отправляет запрос, который повреждает кеш/контекст пользователя.
- **Cloudflare трассировка**: webhook получает события typing/message в правильном порядке, но нет успешных отправок reply.

## Итог-диагноз 2 — точка обрыва
- Воркер жив: `healthz = ok`.
- Bot API жив: `getMe → 200`, `send-admin(chatId=136236606) → 200`; в чате видны «Self-test ping».
- UTM-контур жив: `utm selftest = ok`.
- **Вебхук-петля молчит**: обычный пользователь по диплинку не получает typing и ответа; админские команды также не исполняются.
- Очистка `knownUsers` возвращает `cleared:0` — кэш пустой или рантайм использует другой сегмент.
- Наблюдается рассинхрон ID: `136236606` (рабочий) против `136326606` (ошибка 400 в `send-admin`).

**Вывод:** DIAG-контур работает, а боевой webhook обрывается до `sendTyping/sendMessage`. Проблема сфокусирована на разборе и передаче `chat_id` в основной ветке обработки, а не в токене или доступности Bot API.

## Точки внимания для исправления
1. **Webhook-ветка: целостность `chat_id` (критично).**
   - Сохранять `chat_id` из payload без преобразований (`parseInt`/округлений) во всех маршрутах.
   - Гарантировать, что `sendTyping`/`sendMessage` получают ту же строку ID, что пришла в update, и не опираются на whitelist.
2. **Порядок и устойчивость отправок.**
   - Сделать `sendTyping` fail-soft, чтобы ошибка не обрывала цепочку ответа.
   - Логировать `{update_id, msg_id, chat_id_raw, chat_id_used, route, code}` перед каждым `send*`.
3. **Маршрутизация команд.**
   - Проверить распознавание админских команд после diag-роутов и исключить глобальные флаги «тихого режима».
   - Явно логировать выбранный маршрут (`admin|user|unknown`).
4. **knownUsers.**
   - Убедиться, что webhook использует тот же кэш, что чистит `/admin/known-users/clear`.
   - Если кэш не задействован — вычеркнуть его влияние на запись/ответ.
5. **Диаг-покрытие.**
   - Добавить snapshot «последний вебхук» с безопасными полями (`chat_id_raw`, `chat_id_used`, `route`, `last_send_code`).
   - Фиксировать источник ID (`update` vs `whitelist`) в diag отчётах.

## Гипотезы команды
1. **H1 (root):** в webhook-ветке `chat_id` трансформируется/подменяется → `sendTyping`/`sendMessage` получают неверный ID и падают с 400. (Статус уверенности: знаю.)
2. **H2:** глобальный «тихий режим» (лимитер/безопасность) глушит отправки из webhook, тогда как diag-роуты его обходят. (Статус: частично уверен.)
3. **H3:** кэш `knownUsers`/снапшоты не совпадают с рантаймом, что приводит к раннему выходу обработчика. (Статус: частично уверен.)

## Диагностические задачи (one-click ready)

:::task-stub{title="Переподтвердить self-test без порчи chat_id"}
1. Локально воспроизвести self-test (`bindings`, `telegram.getMe`, `send-admin`) с инструментированным логированием `chatId` до и после `toIdString`.
2. Проверить, фиксируется ли потеря точности в `apps/worker-main/http/telegram-webhook.ts` и вспомогательных хелперах.
3. Обновить памятку с логами, приложить вывод и уточнить, какой шаг портит ID.
:::

:::task-stub{title="Проверить кэш известных пользователей"}
1. В журнале запросов удостовериться, что self-test пишет ID в `knownUsers` и какие значения сохраняются.
2. Если ID обрезан, зафиксировать место записи (`apps/worker-main/features/known-users/*`).
3. Подготовить фиксацию для очистки/валидатора ID в кэше.
:::

:::task-stub{title="Диагностировать OpenAI diagnostic marker"}
1. Проследить, какие параметры self-test отправляет в OpenAI и что ожидает в ответе.
2. Проверить конфигурацию `OPENAI_PROMPT_ID`/маркера в `bindings` и в коде self-test.
3. Подготовить рекомендации по фиксации или отключению маркера на время восстановления Telegram-пайплайна.
:::

:::task-stub{title="Исключить гонку двойного self-test ping"}
1. Проанализировать логи воркера в момент двойного сообщения (в `logs/`/`snapshot/`).
2. Проверить, выполняет ли self-test несколько параллельных `sendTyping/sendMessage` и как они влияют на rate-limit и состояние.
3. Подготовить предложение по сериализации self-test или разделению контекстов.
:::

## Следующие шаги
- Обновить issue [2025-11-16-telegram-id-lossless-parser](../issues/2025-11-16-telegram-id-lossless-parser.md) ссылкой на ретест.
- После подтверждения гипотез запланировать фиксы в RoadMap.
