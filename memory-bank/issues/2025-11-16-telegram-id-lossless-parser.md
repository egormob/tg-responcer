# Инцидент: повторное 400 Bad Request из-за потери точности Telegram ID

**Таймстамп:** 2025-11-16T07:45:00Z (UTC).

## Симптомы
- Telegram API отвечает `400 Bad Request` на исходящие запросы после приёма апдейта.
- Пользователь не видит `typing`-индикатор: `sendTyping` не вызывается после падения пайплайна.
- В логах `http/telegram-webhook` повторяются предупреждения о недопустимом `chat_id`.
- Пакет DIAG-PACKET подтверждает приём входящих апдейтов: webhook продолжает получать события, но отсутствуют исходящие `sendTyping`/`sendMessage`.
- `/admin/selftest` возвращает `AI_NON_2XX`, `/admin/diag` отвечает `Not Found`, что показывает отсутствие рабочей диагностики на воркере.
- По данным Observability (`dash.cloudflare.com`) фиксируются входящие `POST /webhook/...` и сообщения `[telegram-webhook] incoming update`, но в сессии отсутствуют `sendTyping`/`sendMessage` (ни 200, ни 4xx).

## Диагностика (DIAG-PACKET, prod selftests)
1. `/healthz → {"status":"ok"}` — воркер жив.
2. `/admin/selftest?q=utm` возвращает `{ok: true, saveOk: true, readOk: true, utmDegraded: false}` → D1/схема/апсерт UTM в норме.
3. `/admin/selftest?q=ping` даёт `{openAiOk: false, telegramOk: false, errors: ["openai: missing diagnostic marker", "telegram: chatId query parameter is required"], openAiLatencyMs: 4.6–7.5s}` → diag-пинг не валидирует Bot API (ждёт chatId), AI-контур не отдаёт диагностический маркер.
4. `/admin/selftest?q=send-admin&chatId=136326606` выдаёт `{openAiOk: false, telegramOk: false, errors: ["…", "telegram: Bad Request: chat not found"]}` → отправка в Telegram падает, чат с пользователем ранее существовал → вероятна порча `chat_id` на нашей стороне.
5. `/admin/diag?q=telegram.getMe|telegram` отвечает `{"error":"Unsupported diagnostics query"}` → нет базовой проверки Bot API (`getMe`/test-send).
6. `/admin/diag?q=bindings` возвращает `{ok: true, …}`, но токены/секреты (включая `TELEGRAM_BOT_TOKEN`) не подсвечены/не подтверждены явно.
7. `/admin/known-users/clear` отвечает `Not Found` → отсутствует админ-роут для сброса кэша известных пользователей.

## Диагноз (рабочая версия)
- Диалог падает до safe-ветки на первом `messaging.sendTyping` из-за испорченного `chat_id`.
- Корень: lossy-парсинг ID (эвристики + `Math.trunc` в `toIdString`). Любой Telegram ID, прошедший через helper, уходит в Bot API искажённым → 400 → «тишина».
- Тот же helper используется в UTM-снапшоте/кэше, закрепляя неверный ID.

## Затронутые файлы
- `http/parse-json-with-large-integers.ts` — текущий парсер не гарантирует сохранение 64-битных идентификаторов.
- `http/telegram-webhook.ts` — преобразование идентификаторов перед вызовом Telegram.
- `features/utm-tracking/create-telegram-webhook-handler.ts` — использует результат парсинга в критическом пути.
- `core/DialogEngine.ts` — полагается на корректность `userId`/`chat_id` при отправке ответа.

## Несработавшие гипотезы
- [issues/2025-11-11-telegram-id-truncation.md](2025-11-11-telegram-id-truncation.md) — фокус на устранении `Number()` без полноценного lossless-парсера; повторные 400 подтверждают, что подход не закрывает проблему.
- [issues/2025-11-09-dialog-freeze.md](2025-11-09-dialog-freeze.md) — перенос UTM-логики вне критического пути не устранил сброс `chat_id`, симптомы вернулись.
- Обе гипотезы признаны несработавшими: числовой парсинг и перераспределение побочных операций не восстанавливают идентификаторы после усечения. Текущая стратегия строится на полном отказе от любых числовых преобразований Telegram ID.

## Новая стратегия
Lossless-парсер и жёсткие guard'ы должны сохранять идентификаторы Telegram без эвристик по длине. Стратегия строится на полном отказе от числового парсинга: любые промежуточные `Number()`/`parseInt()` считаются дефектом, даже если длина идентификатора совпадает с ожидаемой. Текущие проверки на количество цифр и диапазоны не гарантируют корректность: при `JSON.parse` → `number` мы теряем значимые разряды, даже если длина совпадает. Требуется конвейер, который:
1. Считывает идентификаторы как строки/BigInt-совместимые значения без промежуточного преобразования к `number`.
2. Проводит валидацию через строгие предикаты (префиксы `-100`, диапазон `>=0` для приватных чатов) до передачи в `DialogEngine`.
3. Отбрасывает апдейты с несовместимыми значениями до выхода из HTTP-уровня, чтобы не ломать ядро.

## ЧТО ЧИНИТЬ
**A) Идентификаторы Telegram (КРИТИЧНО)**
- Трактовать все ID как «непрозрачные строки» 1:1 из webhook (`chat_id`, `user.id`, `sender_chat.id`, `migrate_to_chat_id` и т. д.).
- В `toIdString` — жёсткий guard: вход `number` → исключение (никаких `trunc`/`parseInt`).
- Проверить D1: типы ID — `TEXT`, не `INTEGER` (иначе скрытая порча).

**B) Telegram-выход**
- Исключить падение сценария на первом `sendTyping`: fail-soft или перенос ошибки после safe-ветки.
- Гарантировать, что ВСЕ `send*` получают неизменённый string `chat_id`; логировать перед отправкой: id (string, длина, hash) + итоговый HTTP-код Bot API.

**C) Кэш/снапшоты**
- `knownUsers`/UTM-логгер — хранить и возвращать только исходный string id; убрать повторное использование «обрезанного» значения.

**D) Диагностика**
- Добавить diag: `getMe` (показывать username/id бота) и `test-send` без требования `chatId` (использовать whitelisted admin).
- В `bindings`-diag явно подтверждать монтирование `TELEGRAM_BOT_TOKEN` (маскированно).
- Исправить `ping`-selftest: не требовать `chatId` для `telegramOk`, фиксировать код ответа Bot API (200/4xx).

**E) Утилиты**
- Добавить админ-роут для сброса кэша известных пользователей (`known-users/clear`) для ретестов без деплоя.

## Гипотезы (приоритет ↓)
1. **H1 (root):** порча `chat_id` в парсере/хелпере → 400 на `sendTyping` → «тишина».
2. **H2:** где-то в репозиториях/схеме ID всё ещё числовые → дополнительные потери.
3. **H3:** diag-контур неполный, поэтому `telegramOk:false` в `ping` — артефакт сценария, а не реальная проверка токена/Bot API.
4. **H4:** AI-ошибка — побочный шум: до основной AI-ветки мы часто не доходим из-за раннего 400.

## План восстановления
1. Заменить JSON-парсер на `parseJsonWithLargeIntegers` с поддержкой безопасных строк и `BigInt`, гарантируя, что `chat_id` передаётся без потери точности.
2. Добавить guard-функции в `http/telegram-webhook.ts`, которые валидируют формат идентификаторов и возвращают ошибки до вызова `DialogEngine`.
3. Расширить тесты в `features/utm-tracking` и `core/DialogEngine` сценариями с максимально длинными `chat_id` (включая `-100...` групповые ID).
4. Запустить регрессионный прогон webhook ↔ Telegram, убедиться в восстановлении `typing` и отсутствии 400-ответов.

## Критерии приёмки
- `getMe` (diag) возвращает `ok` с username/id бота.
- `test-send` (diag) отвечает `200` и реально отправляет сообщение администратору.
- В обычном диалоге видны typing и ответ; в логах — перед каждым `send*` исходный `chat_id` как строка + код `200`.
- `/admin/selftest?q=ping` → `telegramOk:true` (без `chatId`), `openAiOk:true` или корректный fallback.
- `/admin/selftest?q=utm` остаётся зелёным; диплинк возвращает `users.utm_source`.

## Следующие действия
- Зафиксировать задачу в RoadMap и синхронизировать с командой эксплуатации.
- Обновить журнал стабильных билдов и добавить алерт на повторные 400 от Telegram.
