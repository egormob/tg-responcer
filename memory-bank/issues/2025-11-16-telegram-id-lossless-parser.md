# Инцидент: повторное 400 Bad Request из-за потери точности Telegram ID

**Таймстамп:** 2025-11-16T07:45:00Z (UTC).

## Симптомы
- Telegram API отвечает `400 Bad Request` на исходящие запросы после приёма апдейта.
- Пользователь не видит `typing`-индикатор: `sendTyping` не вызывается после падения пайплайна.
- В логах `http/telegram-webhook` повторяются предупреждения о недопустимом `chat_id`.

## Затронутые файлы
- `http/parse-json-with-large-integers.ts` — текущий парсер не гарантирует сохранение 64-битных идентификаторов.
- `http/telegram-webhook.ts` — преобразование идентификаторов перед вызовом Telegram.
- `features/utm-tracking/create-telegram-webhook-handler.ts` — использует результат парсинга в критическом пути.
- `core/DialogEngine.ts` — полагается на корректность `userId`/`chat_id` при отправке ответа.

## Несработавшие гипотезы
- [issues/2025-11-11-telegram-id-truncation.md](2025-11-11-telegram-id-truncation.md) — фокус на устранении `Number()` без полноценного lossless-парсера; повторные 400 подтверждают, что подход не закрывает проблему.
- [issues/2025-11-09-dialog-freeze.md](2025-11-09-dialog-freeze.md) — перенос UTM-логики вне критического пути не устранил сброс `chat_id`, симптомы вернулись.

## Новая гипотеза
Lossless-парсер и жёсткие guard'ы должны сохранять идентификаторы Telegram без эвристик по длине. Текущие проверки на количество цифр и диапазоны не гарантируют корректность: при JSON.parse → number мы теряем значимые разряды, даже если длина совпадает. Требуется конвейер, который:
1. Считывает идентификаторы как строки/BigInt-совместимые значения без промежуточного преобразования к `number`.
2. Проводит валидацию через строгие предикаты (префиксы `-100`, диапазон `>=0` для приватных чатов) до передачи в `DialogEngine`.
3. Отбрасывает апдейты с несовместимыми значениями до выхода из HTTP-уровня, чтобы не ломать ядро.

## План восстановления
1. Заменить JSON-парсер на `parseJsonWithLargeIntegers` с поддержкой безопасных строк и `BigInt`, гарантируя, что `chat_id` передаётся без потери точности.
2. Добавить guard-функции в `http/telegram-webhook.ts`, которые валидируют формат идентификаторов и возвращают ошибки до вызова `DialogEngine`.
3. Расширить тесты в `features/utm-tracking` и `core/DialogEngine` сценариями с максимально длинными `chat_id` (включая `-100...` групповые ID).
4. Запустить регрессионный прогон webhook ↔ Telegram, убедиться в восстановлении `typing` и отсутствии 400-ответов.

## Следующие действия
- Зафиксировать задачу в RoadMap и синхронизировать с командой эксплуатации.
- Обновить журнал стабильных билдов и добавить алерт на повторные 400 от Telegram.
