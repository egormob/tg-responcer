# Telegram deeplink и UTM-метки

## Быстрые факты
- Базовый deeplink в Telegram имеет вид `https://t.me/<bot_username>?start=<payload>`.
- Для открытия мини-приложений используется `https://t.me/<bot_username>?startapp=<payload>`.
- Payload (`start`/`startapp`) принимается ботом через `ctx.startParam`/`ctx.webAppData` и ограничен **64 символами**. Парсер `parseStartPayload` ожидает префикс `src_` или `src.` и буквы/цифры/символы `._+-` (регистрозависимо), сохраняя строку как есть; при необходимости передавай сжатые токены или base64url.
- Telegram передаёт payload только при первом запуске чата или из кнопок `switch_inline_query`, поэтому повторные клики без `/start` не обновят данные — фиксируй источник в момент первой инициализации пользователя.

## Разметка UTM-параметров
- Для аналитики используем единый формат `src.medium.campaign[.content]`, например `ads.meta.black-friday` → `ads.meta.black-friday`. Такая запись умещается в 64 символов и легко разбирается.
- При необходимости нескольких меток добавляй разделители `+`: `ads.meta.black-friday+retargeting`. Храним строку целиком в `users.utm_source`, а разбор на `utm_source`/`utm_medium`/`utm_campaign`/`utm_content` выполняем уже в BI.
- Резервируй короткие алиасы для часто используемых кампаний (`bf25`, `ref`, `welcome`) и веди таблицу соответствий в CRM, чтобы не превышать лимит.
- Символы, недопустимые в payload (` `, `&`, `=`), заменяй на `-` или кодируй через base64url.

## `start` vs `startapp`
- `start`: передаёт данные только боту. Используй для сценариев, где бот сам отвечает пользователю и сохраняет источник (`/start src.medium.campaign`).
- `startapp`: открывает веб-приложение (Bot API Web App). Payload так же ограничен 64 символами и передаётся в `initData`, поэтому готовь сжатый JSON/токен и декодируй его на стороне приложения.
- При работе с mini app фиксируй источник сразу после получения `initData`, затем передавай идентификатор в API бота или в KV.

## Best practices
1. **Единая нормализация.** Храни payload в исходном виде (`users.utm_source`) и при необходимости раскладывай части уже в аналитике или вспомогательных витринах. Допустимые префиксы `src_`/`src.` и символы `a-zA-Z0-9._+-` подтверждены юнит-тестами от 2025-11-09.
2. **Контроль длины.** Автоматически проверяй, что payload ≤64 символов, иначе отклоняй создание ссылки или сокращай название кампании.
3. **Версионирование кампаний.** Добавляй суффиксы (`-v2`, `-2025q4`) вместо длинных описаний. Полное описание храни в документации/CRM.
4. **Синхронизация с экспортом.** Экспорт `/admin/export` пока не добавляет `utm_*`-колонки. Для BI используй отдельную выборку по `users.utm_source` или дождись задачи [M7 — экспорт UTM](../issues/m7-export-utm-gap.md).
5. **Безопасность.** Не передавай секретные токены в payload — его можно прочитать из URL. Используй одноразовые идентификаторы, которые раскрывают данные только после проверки на сервере.
6. **Логи.** Логируй payload в `ADMIN_EXPORT_LOG` и аналитике при первом сообщении пользователя, чтобы сопоставлять UTM с поведением.

## Чек-лист подготовки deeplink
1. Сформируй UTM-строку `src.medium.campaign[.content]` и убедись, что длина ≤64 символов.
2. Сконструируй ссылку `https://t.me/<bot>?start=<utm>`, либо `startapp=<utm>` для mini app.
3. Протестируй ссылку в тестовом чате: запускаем `/start`, проверяем, что бот сохранил payload в `users.utm_source` (см. `wrangler d1 execute ... SELECT user_id, utm_source FROM users ...`).
4. Задокументируй новую кампанию в `memory-bank/operations/export.md` и добавь правила разбора в аналитике.

## Проверки 2025-11-09
- `npx vitest run apps/worker-main/features/utm-tracking/__tests__/parse-start-payload.test.ts apps/worker-main/http/__tests__/telegram-webhook.test.ts` — подтверждена поддержка payload с точками, плюсом и смешанным регистром.
