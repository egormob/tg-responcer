# RoadMap

## Контекст и цели
- Репозиторий `tg-responcer` управляется по базовому протоколу из `Protocol.md`.
- Дорожная карта служит единственным источником истины о шагах, проверках и состоянии создания Telegram-бота на OpenAI Responses через Cloudflare Workers.
- **Цель проекта:** собрать устойчивого Telegram-бота с модульной архитектурой: базовый диалоговый контур (ядро + память), выгрузка диалогов, ручные рассылки, лимиты на ответы и индикация `typing…`. Ассистент и инструменты настраиваются в OpenAI Responses, код использует только `assistant_id`.

## Принципы работы
1. Следовать протоколу: поддерживать артефакты `RoadMap.md` и `memory-bank/`, хранить логи/снапшоты вне git.
2. Работать партиями до ≈150 файлов, контролировать `git diff --stat`, выполнять проверки после каждой партии.
3. Каждый подпункт дорожной карты завершать отдельным коммитом и фиксировать прогресс здесь.
4. Поддерживать линейность истории ветки `work`, избегать расходящихся коммитов.
5. Перед началом задачи сверяться с архитектурой, рисками и актуальной картиной системы.

## Структура

**Цель:** устойчивый диалоговый контур с возможностью подключать апгрейды (экспорт, рассылка, лимиты) без изменений и рисков для базы.

**Слои и их роли:**
- **Ядро (`core/`)** — последовательность шагов диалога (лимит → запись → ответ ИИ → запись → отправка). Никаких SDK/HTTP. Статус: **FROZEN**.
- **Порты (`ports/`)** — четыре стабильных интерфейса: `MessagingPort` (`sendTyping`, `sendText`), `AiPort` (`reply({ userId, text, context }) → { text }`), `StoragePort` (`saveUser`, `appendMessage`, `getRecentMessages`), `RateLimitPort` (`checkAndInc → "ok" | "limit"`).
- **Адаптеры (`adapters/*`)** — реализации портов (Telegram, OpenAI Responses, D1, KV и т.п.).
- **NOOP-адаптеры (`adapters-noop/*`)** — безопасные заглушки для каждого порта по умолчанию.
- **Композиция (`composition/`)** — сборка адаптеров, регистрация фич и чтение KV-флагов.
- **HTTP (`http/`)** — только роутинг: `POST /webhook/:secret` (включая обработку команд/админа до ядра), `GET /healthz`, `/admin/*` (роуты фич).
- **Фичи (`features/*`)** — апгрейды как отдельные модули (экспорт CSV, рассылка, лимиты). Подключаются через `composition/register-features.ts` в `try/catch`; при сбое ядро остаётся рабочим.

**Инварианты Responses:**
- Промпты/файлы/инструменты управляются в OpenAI Responses, воркер использует `OPENAI_ASSISTANT_ID` и обычный REST-запрос `POST /v1/responses` без стриминга.
- При ответе показываем `typing…`, затем отправляем финальное сообщение.
- Контекст для модели — короткий хвост из `StoragePort.getRecentMessages`.

**Хранилища и флаги:**
- Диалоги и пользователи — Cloudflare D1 (Paid до 10 ГБ, Free до 500 МБ).
- Лимиты и фич-флаги — Cloudflare KV (`STREAMING`, `BROADCAST`, `EXPORT_ENABLED`, `LIMITS_ENABLED` и др.).
- Админ-доступ: `/admin/*` через заголовок `X-Admin-Token`, чат-команды — whitelist `ADMIN_IDS`.

**Технические предохранители:** `CODEOWNERS` на `/core` и `/ports`, CI-гард, eslint-правила против сквозных импортов.

## Правила
1. **FROZEN CORE.** `core/` меняем только с bump `core/VERSION` и ревью владельца.
2. **Стабильные порты.** Сигнатуры в `ports/` неизменны без версионирования и ревью.
3. **Только через порты.** Ядро не импортирует SDK, HTTP или биндинги Cloudflare.
4. **Команды до ядра.** `/admin`, `/broadcast` и служебные команды обрабатываются в `http/`, а не в `DialogEngine`.
5. **Фичи не трогают ядро.** Новые функции живут в `features/*` и подключаются через `composition/` под KV-флаги.
6. **NOOP по умолчанию.** При отсутствии адаптера/фичи используется заглушка, диалог остаётся работоспособным.
7. **Без промптов в коде.** Настройка ассистента — только в Responses (`OPENAI_ASSISTANT_ID`).
8. **Админ-охранник.** `/admin/*` требует `X-Admin-Token`; чат-команды доступны только `ADMIN_IDS`.
9. **Мягкая деградация.** Внешние вызовы защищены `try/catch` и таймаутами, ошибки логируем без остановки ядра.
10. **Троттлинг и лимиты.**
    - Применяется к массовым отправкам (рассылки, циклы). Обычные ответы ядра не троттлим.
    - Лимиты Telegram: ≤30 сообщений/сек глобально, ≤1 сообщение/сек в личный чат, ≤20 сообщений/мин в группы/каналы.
    - При `429 Too Many Requests` читаем `retry_after`, ждём указанное время, используем экспоненциальную задержку с джиттером, не более трёх ретраев, затем логируем и пропускаем адресата.
    - Отправляем батчами с паузами, порядок внутри батча не критичен.
    - При росте объёмов выносим рассылки в Cloudflare Queues (ретраи, батч-обработка) без изменений ядра.
11. **Тесты-сторожа.** Контракты портов, смоук `/webhook` с моками, проверка отключённых фич.
12. **Guardrails в репо.** `CODEOWNERS`, CI-гард и eslint обеспечивают замороженное ядро и корректные импорты.
13. **Retain & Rotate.** Политика хранения диалогов, крупные выгрузки — CSV с пагинацией или очередями.
14. **Флаги — источник правды.** Подключение/отключение фич происходит через KV и `composition/`.

## Майлстоуны проекта

### Майлстоун 0. Операционная система управления проектом *(завершён 2025-10-23)*
**Цель:** зафиксировать протокол, дорожную карту и структуру памяти.

**Шаги и проверки:**
1. Создать `RoadMap.md`, каталог `memory-bank/`, зафиксировать журнал.
   - **Результат:** артефакты операционной системы присутствуют.
   - **Проверка:** `ls` показывает файлы; дорожная карта описывает цели и принципы.
2. Настроить контроль линейности ветки и журнал прогресса.
   - **Результат:** описаны меры контроля истории ветки и рисков.
   - **Проверка:** раздел «Принципы работы» отражает правила линейности.

**Критерий приёмки:** RoadMap и память созданы, правила зафиксированы.

### Майлстоун 1. Frozen Core Scaffold
**Цель:** подготовить каркас воркера с замороженным ядром и портами, чтобы дальнейшие апгрейды подключались без риска.

**Зависимости:** майлстоун 0.

**Шаги и проверки:**
1. Стартовая структура воркера.
   - **Результат:** каталоги `apps/worker-main/{core,ports,adapters,adapters-noop,composition,http,features,shared}` с базовыми индексами.
   - **Проверка:** `tree apps/worker-main -L 2` показывает структуру.
   - **Внешние действия:** не требуются.
2. Реализация `core/DialogEngine.ts` и контрактов.
   - **Результат:** минимальный контур диалога вызывает порты в нужном порядке; файл помечен баннером FROZEN.
   - **Проверка:** юнит-тест `DialogEngine` с моками (`npm run test -- dialog-engine`).
3. Определение портов и NOOP-адаптеров.
   - **Результат:** интерфейсы для Messaging/Ai/Storage/RateLimit и заглушки возвращающие безопасные значения.
   - **Проверка:** TypeScript компиляция `npm run typecheck` проходит; тесты на NOOP (например, проверка, что не падают).
4. Композиция и HTTP-роутер.
   - **Результат:** `composition/compose.ts` выбирает адаптеры или NOOP, `http/router.ts` объявляет `/webhook`, `/healthz`.
   - **Проверка:** интеграционный тест с моками (`npm run test -- http-router`), ручной вызов `wrangler dev` + `curl /healthz` (сообщить результат).
5. Guardrails.
   - **Результат:** `CODEOWNERS`, CI-гард (GitHub Actions), eslint-правила запретов импортов, файл `core/VERSION`.
   - **Проверка:** `npm run lint` без ошибок; CI локально: `npm run validate-guards` (скрипт проверяет VERSION); визуальная проверка `CODEOWNERS`.

**Критерии приёмки:** структура собирается `npm run build`, тесты проходят, CI-гарды действуют. Внешняя команда подтверждает, что `wrangler dev` запускается и `/healthz` отвечает 200.

### Майлстоун 2. Telegram Webhook & Messaging Adapter
**Цель:** приём обновлений Telegram, показ `typing…`, отправка ответов через адаптер, команды обрабатываются до ядра.

**Зависимости:** майлстоун 1.

**Шаги и проверки:**
1. Telegram-парсер апдейтов и роут вебхука.
   - **Результат:** `http/telegram-webhook.ts` извлекает текстовые сообщения, команды `/admin*` направляет в фичи.
   - **Проверка:** юнит-тесты на разных видах апдейтов (`npm run test -- telegram-webhook`).
2. Messaging адаптер.
   - **Результат:** `adapters/telegram` реализует `MessagingPort` (`sendTyping`, `sendText`) через `fetch` Telegram API.
   - **Проверка:** мок-тесты адаптера, подтверждающие корректное формирование запросов.
3. Конфигурация секретов и деплой.
   - **Внешние действия:**
     - В Wrangler: `wrangler secret put TELEGRAM_BOT_TOKEN`.
     - Настроить `TELEGRAM_WEBHOOK_SECRET` (для URL).
     - Установить вебхук командой `curl https://api.telegram.org/bot<TOKEN>/setWebhook` на `https://<worker>/webhook/<secret>`.
   - **Проверка:** после деплоя отправить тестовое сообщение, сообщить агенту payload и ответ; `wrangler tail` без ошибок.
4. Typing-индикация.
   - **Результат:** воркер отправляет `sendChatAction` до обращения к ядру и завершает после ответа.
   - **Проверка:** в Telegram клиенте видна индикация typing перед ответом; подтверждение от команды.

**Критерии приёмки:** вручную проверено, что сообщение из Telegram проходит через воркер, вызывает NOOP-AI и возвращает заглушечный ответ, а команды `/admin` не пробрасываются в ядро.

### Майлстоун 3. OpenAI Responses Integration
**Цель:** подключить OpenAI Responses как источник ответов, используя REST `/v1/responses` без стриминга.

**Зависимости:** майлстоуны 1–2.

**Шаги и проверки:**
1. Адаптер `AiPort` для Responses.
   - **Результат:** `adapters/openai-responses` формирует запрос `POST https://api.openai.com/v1/responses` с `assistant_id`, диалоговым контекстом и обрабатывает ошибки.
   - **Проверка:** юнит-тесты с `fetch-mock` проверяют тело запроса и обработку ошибок; `npm run test -- openai-adapter`.
2. Конфигурация секретов.
   - **Внешние действия:**
     - `wrangler secret put OPENAI_API_KEY`.
     - `wrangler secret put OPENAI_ASSISTANT_ID`.
   - **Проверка:** пробный вызов `wrangler dev` с тестовым запросом, лог успешного ответа.
3. Интеграция с ядром.
   - **Результат:** `DialogEngine` через порт получает ответ, передаёт текст адаптеру Telegram.
   - **Проверка:** E2E тест через `wrangler dev` с отправкой сообщения; сообщить сэмпл-ответ от ассистента.
4. Обработка деградаций.
   - **Результат:** при ошибке Responses бот отправляет запасной ответ и логирует ошибку, ядро не падает.
   - **Проверка:** тест с симулированным `500` (мок) проверяет fallback; команда подтверждает что Telegram ответ содержит сообщение об ошибке.

**Критерии приёмки:** бот отвечает реальным текстом от Responses, fallback работает, секреты заданы.

### Майлстоун 4. D1 Persistence & Диалоговая память
**Цель:** хранить пользователей и историю диалогов в D1, предоставлять короткий контекст ядру.

**Зависимости:** майлстоуны 1–3.

**Шаги и проверки:**
1. Схема базы и миграции.
   - **Результат:** SQL миграции для таблиц `users`, `messages` (user_id, role, content, timestamps, metadata).
   - **Проверка:** `wrangler d1 execute <DB> --file=...` создаёт таблицы без ошибок.
   - **Внешние действия:** создать D1 binding `wrangler d1 create dialog-db`, привязать в `wrangler.toml` как `DB`.
2. Адаптер `StoragePort` для D1.
   - **Результат:** CRUD-операции сохраняют пользователей и сообщения, `getRecentMessages` возвращает N последних реплик.
   - **Проверка:** тесты с `@cloudflare/workers-types` + `better-sqlite3` (локально) проверяют вставку/чтение.
3. Интеграция в композицию.
   - **Результат:** `compose.ts` подключает адаптер при наличии D1 binding, иначе NOOP.
   - **Проверка:** `npm run test -- composition-storage`.
4. Диалоговая память.
   - **Результат:** ядро запрашивает последние N сообщений и передаёт их Responses; сохраняет и исходное, и ответ.
   - **Проверка:** E2E прогон: отправить 3 сообщения, убедиться, что D1 содержит записи (команда запускает `wrangler d1 execute` SELECT и сообщает результат).

**Критерии приёмки:** данные пишутся в D1, Responses получает контекст, бот отвечает, история доступна.

### Майлстоун 5. Rate Limit Feature
**Цель:** ограничивать количество ответов пользователю в сутки с помощью KV и промптового уведомления.

**Зависимости:** майлстоуны 1–4.

**Шаги и проверки:**
1. KV-хранилище и адаптер `RateLimitPort`.
   - **Результат:** реализация инкремента суточных счётчиков, TTL = 24ч.
   - **Проверка:** юнит-тесты с локальным KV-симулятором (`miniflare`) проверяют достижение лимита.
   - **Внешние действия:** создать KV namespace `wrangler kv:namespace create RATE_LIMIT`, привязать как `RATE_LIMIT_KV`.
2. Фича `features/limits`.
   - **Результат:** middleware блокирует ядро при превышении лимита, отправляет пользователю уведомление, логирует событие.
   - **Проверка:** интеграционный тест с имитацией нескольких запросов; `npm run test -- limits`.
3. Конфигурация KV-флага.
   - **Результат:** `KV` ключ `LIMITS_ENABLED` включает/отключает middleware.
   - **Проверка:** ручной тест: переключить ключ через `wrangler kv:key put`, убедиться, что лимит срабатывает/не срабатывает.

**Критерии приёмки:** лимит блокирует ответы после N сообщений в сутки и легко отключается флагом.

### Майлстоун 6. Export CSV Feature
**Цель:** выгружать диалоги из D1 в CSV по запросу администратора.

**Зависимости:** майлстоуны 1–5.

**Шаги и проверки:**
1. HTTP-роут `/admin/export`.
   - **Результат:** принимает диапазон дат/пагинацию, проверяет `X-Admin-Token`.
   - **Проверка:** юнит-тесты авторизации и валидации входа.
2. CSV-генератор.
   - **Результат:** потоковая генерация CSV (chunked) поверх выборки D1, избегая больших ответов.
   - **Проверка:** тест на генерацию >100 записей, проверка памяти (отсутствие утечек).
3. Внешняя проверка.
   - **Внешние действия:** команда выполняет `curl -H "X-Admin-Token: ..." https://<worker>/admin/export?from=...` и подтверждает получение корректного CSV.

**Критерии приёмки:** админ может скачать CSV, формат совместим с Excel, запрос защищён токеном.

### Майлстоун 7. Broadcast Feature
**Цель:** ручная рассылка сообщений пользователям с соблюдением лимитов Telegram.

**Зависимости:** майлстоуны 1–6.

**Шаги и проверки:**
1. Маршрут `/admin/broadcast` и очередь отправок.
   - **Результат:** эндпоинт принимает текст/фильтры, инициирует рассылку через воркер (пакетная отправка + троттлинг).
   - **Проверка:** юнит-тесты проверяют валидацию и старт рассылки.
2. Планировщик отправок.
   - **Результат:** модуль очереди (на старте — в памяти, затем опционально Cloudflare Queues) обрабатывает пачки с задержками, уважая лимиты.
   - **Проверка:** тесты симулируют массовую рассылку, проверяют обработку `429` и повторов.
3. Внешние действия.
   - **Внешние действия:**
     - Настроить KV-флаг `BROADCAST_ENABLED`.
     - (Опционально) создать Queue `wrangler queues create broadcast-queue` и привязать.
   - **Проверка:** команда запускает тестовую рассылку на 2–3 пользователей и подтверждает получение сообщений без ошибок в логах.

**Критерии приёмки:** рассылка отправляется, соблюдая троттлинг, при ошибках отдельные пользователи пропускаются без падения ядра.

### Майлстоун 8. Observability & Operations
**Цель:** обеспечить мониторинг, алерты и устойчивость к сбоям.

**Зависимости:** майлстоуны 1–7.

**Шаги и проверки:**
1. Логирование и трассировка.
   - **Результат:** единый логгер в `shared/` с контекстом (requestId, userId); интеграция с `wrangler tail`.
   - **Проверка:** `npm run test -- logger` и ручная проверка логов.
2. Метрики и алерты.
   - **Результат:** экспорт технических метрик (ответы, ошибки, латентность) в Workers Analytics Engine или сторонний сервис.
   - **Проверка:** отчёт команды о появлении метрик в панели; автоматический smoke-тест.
3. Операционные инструкции.
   - **Результат:** документы в `memory-bank/` с инструкциями по обновлению ассистента, ротации секретов, процедурам инцидентов.
   - **Проверка:** ревью содержимого, подтверждение команды.

**Критерии приёмки:** логи и метрики доступны, документация покрывает стандартные операции.

### Майлстоун 9. Post-MVP Enhancements (опциональный backlog)
**Цель:** подготовить пространство для расширения (например, .xlsx, мультиязычность, очереди).

**Идеи и проверки:**
- Экспорт `.xlsx` через очередь и R2.
- Автономное тестирование промптов Responses.
- Сегментация пользователей для рассылок.
Каждый пункт потребует отдельной декомпозиции перед стартом.

## Журнал прогресса
- 2025-10-23: Инициализирована дорожная карта и создан каталог памяти (этап текущей сессии).
- 2025-10-23: Обновлена структура и правила дорожной карты.
- 2025-10-23: Сформирована детальная дорожная карта с майлстоунами 1–9.

## Быстрый протокол действий
1. Проверить ветку и статус репозитория.
2. Ознакомиться с `RoadMap.md` и памятками в `memory-bank/`.
3. Составить микроплан и выполнить изменения ограниченной партией.
4. Запустить проверки, просмотреть изменения, обновить журнал и памятки.
5. Закоммитить изменения, подготовить PR через `make_pr`.
