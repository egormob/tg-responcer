# RoadMap

## Контекст и цели
- Репозиторий `tg-responcer` управляется по базовому протоколу из `Protocol.md`.

- Дорожная карта служит единственным источником истины о шагах, проверках и состоянии создания Telegram-бота на OpenAI Responses через Cloudflare Workers.
- **Цель проекта:** собрать устойчивого Telegram-бота с модульной архитектурой: базовый диалоговый контур (ядро + память), выгрузка диалогов, ручные рассылки, лимиты на ответы и индикация `typing…`. Ассистент и инструменты настраиваются в OpenAI Responses, код использует только `assistant_id`.

## Принципы работы
1. Следовать протоколу: поддерживать артефакты `RoadMap.md` и `memory-bank/`, хранить логи/снапшоты вне git.
2. Работать партиями до ≈150 файлов, контролировать `git diff --stat`, выполнять проверки после каждой партии.
3. Каждый подпункт дорожной карты завершать отдельным коммитом и фиксировать прогресс здесь.
4. Поддерживать линейность истории ветки `work`, избегать расходящихся коммитов.
5. Перед началом задачи сверяться с архитектурой, рисками и актуальной картиной системы.
6. Перед подготовкой PR синхронизировать ветку `work` с целевой базой, убедиться в отсутствии merge-конфликтов и зафиксировать
   в журнале, если конфликт решался вручную.

## Анализ рисков и допущений

- **Инфраструктура.** Предполагается доступ к Cloudflare Workers, KV, D1, Queues, Telegram Bot API и OpenAI Responses. Любые изменения тарифов или API требуют синхронизации с владельцем продукта до начала работ.
- **Безопасность секретов.** Все секреты заносятся через `wrangler secret`, не хранятся в репозитории и обновляются по чек-листу из `memory-bank/`.
- **Релизы.** Единственный способ деплоя — `wrangler deploy` из проверенной ветки `work` с тегированием релизов. Hotfix вне дорожной карты фиксируется в журнале прогресса отдельной записью.
- **Окна недоступности.** Любые миграции D1 или крупные рассылки согласуются заранее; при необходимости паузы в приёме вебхуков включается maintenance-флаг в KV и уведомляется команда.
- **Внешние зависимости.** Telegram и OpenAI могут возвращать недокументированные ошибки — каждая точка вызова должна иметь защиту таймаутом, повтором и fallback-сообщением.

Пока допущения выполняются, дорожная карта остаётся валидной. При нарушении допущения шаг пересматривается до начала реализации.

## Структура

**Цель:** устойчивый диалоговый контур с возможностью подключать апгрейды (экспорт, рассылка, лимиты) без изменений и рисков для базы.

**Слои и их роли:**
- **Ядро (`core/`)** — последовательность шагов диалога (лимит → запись → ответ ИИ → запись → отправка). Никаких SDK/HTTP. Статус: **FROZEN**.
- **Порты (`ports/`)** — четыре стабильных интерфейса: `MessagingPort` (`sendTyping`, `sendText`), `AiPort` (`reply({ userId, text, context }) → { text }`), `StoragePort` (`saveUser`, `appendMessage`, `getRecentMessages`), `RateLimitPort` (`checkAndInc → "ok" | "limit"`).
- **Адаптеры (`adapters/*`)** — реализации портов (Telegram, OpenAI Responses, D1, KV и т.п.).
- **NOOP-адаптеры (`adapters-noop/*`)** — безопасные заглушки для каждого порта по умолчанию.
- **Композиция (`composition/`)** — сборка адаптеров, регистрация фич и чтение KV-флагов.
- **HTTP (`http/`)** — только роутинг: `POST /webhook/:secret` (включая обработку команд/админа до ядра), `GET /healthz`, `/admin/*` (роуты фич).
- **Фичи (`features/*`)** — апгрейды как отдельные модули (экспорт CSV, рассылка, лимиты). Подключаются через `composition/register-features.ts` в `try/catch`; при сбое ядро остаётся рабочим.

**Инварианты Responses:**
- Промпты/файлы/инструменты управляются в OpenAI Responses, воркер использует `OPENAI_ASSISTANT_ID` и обычный REST-запрос `POST /v1/responses` без стриминга.
- При ответе показываем `typing…`, затем отправляем финальное сообщение.
- Контекст для модели — короткий хвост из `StoragePort.getRecentMessages`.

**Хранилища и флаги:**
- Диалоги и пользователи — Cloudflare D1 (Paid до 10 ГБ, Free до 500 МБ).
- Лимиты и фич-флаги — Cloudflare KV (`STREAMING`, `BROADCAST`, `EXPORT_ENABLED`, `LIMITS_ENABLED` и др.).
- Админ-доступ: `/admin/*` через заголовок `X-Admin-Token`, чат-команды — whitelist `ADMIN_IDS`.

**Технические предохранители:** `CODEOWNERS` на `/core` и `/ports`, CI-гард, eslint-правила против сквозных импортов, ручной чек-лист релиза в `memory-bank/operations.md`.

## Правила
1. **FROZEN CORE.** `core/` меняем только с bump `core/VERSION` и ревью владельца.
2. **Стабильные порты.** Сигнатуры в `ports/` неизменны без версионирования и ревью.
3. **Только через порты.** Ядро не импортирует SDK, HTTP или биндинги Cloudflare.
4. **Команды до ядра.** `/admin`, `/broadcast` и служебные команды обрабатываются в `http/`, а не в `DialogEngine`.
5. **Фичи не трогают ядро.** Новые функции живут в `features/*` и подключаются через `composition/` под KV-флаги.
6. **NOOP по умолчанию.** При отсутствии адаптера/фичи используется заглушка, диалог остаётся работоспособным.
7. **Без промптов в коде.** Настройка ассистента — только в Responses (`OPENAI_ASSISTANT_ID`).
8. **Админ-охранник.** `/admin/*` требует `X-Admin-Token`; чат-команды доступны только `ADMIN_IDS`.
9. **Мягкая деградация.** Внешние вызовы защищены `try/catch` и таймаутами, ошибки логируем без остановки ядра.
10. **Троттлинг и лимиты.**
    - Применяется к массовым отправкам (рассылки, циклы). Обычные ответы ядра не троттлим.
    - Лимиты Telegram: ≤30 сообщений/сек глобально, ≤1 сообщение/сек в личный чат, ≤20 сообщений/мин в группы/каналы.
    - При `429 Too Many Requests` читаем `retry_after`, ждём указанное время, используем экспоненциальную задержку с джиттером, не более трёх ретраев, затем логируем и пропускаем адресата.
    - Отправляем батчами с паузами, порядок внутри батча не критичен.
    - При росте объёмов выносим рассылки в Cloudflare Queues (ретраи, батч-обработка) без изменений ядра.
11. **Тесты-сторожа.** Контракты портов, смоук `/webhook` с моками, проверка отключённых фич.
12. **Guardrails в репо.** `CODEOWNERS`, CI-гард и eslint обеспечивают замороженное ядро и корректные импорты.
13. **Retain & Rotate.** Политика хранения диалогов, крупные выгрузки — CSV с пагинацией или очередями.
14. **Флаги — источник правды.** Подключение/отключение фич происходит через KV и `composition/`.

## Майлстоуны проекта

### Майлстоун 0. Операционная система управления проектом *(завершён 2025-10-23)*
**Цель:** зафиксировать протокол, дорожную карту и структуру памяти.

**Шаги и проверки:**
1. Создать `RoadMap.md`, каталог `memory-bank/`, зафиксировать журнал.
   - **Результат:** артефакты операционной системы присутствуют.
   - **Проверка:** `ls` показывает файлы; дорожная карта описывает цели и принципы.
2. Настроить контроль линейности ветки и журнал прогресса.
   - **Результат:** описаны меры контроля истории ветки и рисков.
   - **Проверка:** раздел «Принципы работы» отражает правила линейности.

**Риски и предохранители:** убедиться, что нет других файлов с конфликтующими инструкциями; зафиксировать ссылку на протокол в `memory-bank/`.

**Критерий приёмки:** RoadMap и память созданы, правила зафиксированы.

### Майлстоун 1. Frozen Core Scaffold
**Цель:** подготовить каркас воркера с замороженным ядром и портами, чтобы дальнейшие апгрейды подключались без риска.

**Зависимости:** майлстоун 0.

**Шаги и проверки:**
1. Стартовая структура воркера.
   - **Результат:** каталоги `apps/worker-main/{core,ports,adapters,adapters-noop,composition,http,features,shared}` с базовыми индексами и заглушечными `index.ts`/`README` для ориентирования.
   - **Проверка:** `tree apps/worker-main -L 2` показывает структуру (в CI допускается `find apps/worker-main -maxdepth 2 -type d`).
   - **Внешние действия:** не требуются.
   - **Статус:** ✅ Каркас каталогов и заглушки созданы, структура соответствует плану.
2. Реализация `core/DialogEngine.ts` и контрактов.
   - **Результат:** минимальный контур диалога вызывает порты в последовательности «лимит → запись входа → ответ ИИ → запись ответа → отправка», интерфейсы экспортируются из `ports/`, файл помечен баннером FROZEN.
   - **Проверка:** юнит-тест `DialogEngine` с моками (`npm run test:core`) покрывает порядок вызовов и обработку ошибок; отчёт о покрытии сохраняется в `logs/`.
   - **Статус:** ✅ Контур реализован, тесты подготовлены (`vitest`). Запуск ожидает установки npm-зависимостей (в среде агента `npm install` завершился ошибкой 403).
3. Определение портов и NOOP-адаптеров.
   - **Результат:** интерфейсы для Messaging/Ai/Storage/RateLimit и заглушки, возвращающие безопасные значения и логирующие предупреждения, чтобы облегчить отладку; JSDoc поясняет контракт по таймингам и повторам.
   - **Проверка:** `npm run typecheck` проходит; unit-тесты NOOP подтверждают отсутствие побочных эффектов; eslint-правило запрещает прямые импорты в `core/`.
   - **Статус:** ✅ Контракты уточнены, заглушки реализованы, добавлены юнит-тесты (запуск тестов ожидает доступа к npm registry, `npm install` возвращает 403).
4. Композиция и HTTP-роутер.
   - **Результат:** `composition/compose.ts` выбирает адаптеры или NOOP в зависимости от доступных биндингов, `http/router.ts` объявляет `/webhook/:secret` и `/healthz`, webhook проверяет секрет и проксирует в `DialogEngine`.
   - **Проверка:** интеграционный тест с моками (`npm run test -- http-router`), ручной вызов `wrangler dev` + `curl /healthz` (сообщить результат); лог или скриншот команды сохраняется в `logs/`.
   - **Статус:** ✅ Реализованы композиция и HTTP-роутер с покрытием unit-тестами (`apps/worker-main/http/__tests__/router.test.ts`, `apps/worker-main/composition/__tests__/compose.test.ts`); роут `/healthz` возвращает `status: ok`, webhook валидирует секрет и проксирует вызов в `DialogEngine`.
5. Guardrails.
   - **Результат:** `CODEOWNERS`, CI-гард (GitHub Actions), eslint-правила запретов импортов, файл `core/VERSION` и скрипт `npm run validate-guards`, который срабатывает при изменении `core/` без bump версии.
   - **Проверка:** `npm run lint` без ошибок; `npm run validate-guards` отрабатывает без сбоев; визуальная проверка `CODEOWNERS`; вручную симулируем изменение в `core/` без bump и убеждаемся, что guard падает.
   - **Статус:** ✅ Добавлены `CODEOWNERS`, workflow CI (lint, test, validate-guards), правило `no-restricted-imports` и файл `core/VERSION`; guard скрипт блокирует изменения ядра без bump (локальный запуск требует `npm install`, которое в среде агента даёт 403 на npm registry).

**Риски и предохранители:** закрепить владельцев `core/` и `ports/`; проверять, что адаптеры не импортируют `core/` напрямую; хранить скриншоты запусков проверок.

**Критерии приёмки:** структура собирается `npm run build`, тесты проходят, CI-гарды действуют. Внешняя команда подтверждает, что `wrangler dev` запускается и `/healthz` отвечает 200.

### Майлстоун 2. Telegram Webhook & Messaging Adapter
**Цель:** приём обновлений Telegram, показ `typing…`, отправка ответов через адаптер, команды обрабатываются до ядра.

**Зависимости:** майлстоун 1.

**Шаги и проверки:**
1. Telegram-парсер апдейтов и роут вебхука.
   - **Результат:** `http/telegram-webhook.ts` валидирует секрет, извлекает текстовые сообщения, команды `/admin*` направляет в фичи без обращения к ядру.
   - **Проверка:** юнит-тесты на разных видах апдейтов (`npm run test -- telegram-webhook`) и проверка, что неверный секрет отвергается; негативные тесты на отсутствующие поля и нестандартные апдейты.
   - **Статус:** ✅ Реализован парсер Telegram-апдейтов, команды `/admin*` перенаправляются в фичи, добавлены модульные тесты и расширен HTTP-роутер для раннего завершения запроса.
2. Messaging адаптер.
   - **Результат:** `adapters/telegram` реализует `MessagingPort` (`sendTyping`, `sendText`) через `fetch` Telegram API, учитывает chat_id и возможные ошибки API.
   - **Проверка:** мок-тесты адаптера, подтверждающие корректное формирование запросов и разбор `retry_after`; нагрузочный тест на серию из 10 сообщений выявляет троттлинг-ошибки.
   - **Статус:** ✅ Добавлен адаптер `createTelegramMessagingAdapter` с ретраями, очисткой текста и поддержкой `retry_after`; покрыт модульными тестами на happy-path и ошибки.
3. Конфигурация секретов и деплой.
   - **Внешние действия:**
     - В Wrangler: `wrangler secret put TELEGRAM_BOT_TOKEN`.
     - Настроить `TELEGRAM_WEBHOOK_SECRET` (для URL).
     - Установить вебхук командой `curl https://api.telegram.org/bot<TOKEN>/setWebhook` на `https://<worker>/webhook/<secret>`.
   - **Проверка:** после деплоя отправить тестовое сообщение, сообщить агенту payload и ответ; `wrangler tail` без ошибок; в журнале прогресса фиксируем время и результат ручного теста.
4. Typing-индикация.
   - **Результат:** воркер вызывает `sendTyping` до обращения к ядру и завершает после ответа; повторные сообщения не запускают параллельных `sendTyping`.
   - **Проверка:** в Telegram клиенте видна индикация typing перед ответом; подтверждение от команды, лог показывает корректные вызовы; автоматический тест имитирует долгий ответ ИИ и проверяет отключение typing.
   - **Статус:** ✅ Добавлен менеджер typing-индикации, `createTypingIndicator` запускает `sendTyping` до вызова ядра и предотвращает
     параллельные индикаторы; покрыто юнит-тестами (`typing-indicator.test.ts`, `router.test.ts`).

**Риски и предохранители:** не логировать секреты; обработать команды `/start` и сервисные сообщения; мониторить `wrangler tail` на неожиданные типы апдейтов.

**Критерии приёмки:** вручную проверено, что сообщение из Telegram проходит через воркер, вызывает NOOP-AI и возвращает заглушечный ответ, а команды `/admin` не пробрасываются в ядро.

### Майлстоун 3. OpenAI Responses Integration
**Цель:** подключить OpenAI Responses как источник ответов, используя REST `/v1/responses` без стриминга.

**Зависимости:** майлстоуны 1–2.

**Шаги и проверки:**
1. Адаптер `AiPort` для Responses.
   - **Результат:** `adapters/openai-responses` формирует запрос `POST https://api.openai.com/v1/responses` с `assistant_id`, диалоговым контекстом, таймаутом и обработкой ошибок/ретраев (до 2 повторов).
   - **Проверка:** юнит-тесты с `fetch-mock` проверяют тело запроса, таймаут и обработку ошибок; `npm run test -- openai-adapter`; проверяется логирование requestId/responseId.
   - **Статус:** ✅ Реализован адаптер `createOpenAIResponsesAdapter`, добавлены модульные тесты `apps/worker-main/adapters/openai-responses/__tests__/openai-responses.test.ts`, покрывающие ретраи, таймаут и очистку текста.
2. Конфигурация секретов.
   - **Внешние действия:**
     - `wrangler secret put OPENAI_API_KEY`.
     - `wrangler secret put OPENAI_ASSISTANT_ID`.
   - **Проверка:** пробный вызов `wrangler dev` с тестовым запросом, лог успешного ответа; убеждаемся, что ключ не попал в stdout.
3. Интеграция с ядром.
   - **Результат:** `DialogEngine` через порт получает ответ, передаёт текст адаптеру Telegram, fallback остаётся прозрачным для ядра.
   - **Проверка:** E2E тест через `wrangler dev` с отправкой сообщения; лог содержит requestId и сэмпл-ответ ассистента; тестовое окружение использует зашифрованные переменные.
4. Обработка деградаций.
   - **Результат:** при ошибке Responses бот отправляет запасной ответ и логирует ошибку с requestId, ядро не падает.
   - **Проверка:** тест с симулированным `500` (мок) проверяет fallback; команда подтверждает, что Telegram ответ содержит дружелюбное сообщение об ошибке; метрика ошибок Responses инкрементируется.

**Риски и предохранители:** таймаут ≤20 с на запрос Responses; не логировать персональные данные; мониторить количество повторов.

**Критерии приёмки:** бот отвечает реальным текстом от Responses, fallback работает, секреты заданы.

### Майлстоун 4. D1 Persistence & Диалоговая память
**Цель:** хранить пользователей и историю диалогов в D1, предоставлять короткий контекст ядру.

**Зависимости:** майлстоуны 1–3.

**Шаги и проверки:**
1. Схема базы и миграции.
   - **Результат:** SQL миграции для таблиц `users`, `messages` (user_id, role, content, timestamps, metadata).
   - **Проверка:** `wrangler d1 execute <DB> --file=...` создаёт таблицы без ошибок; локально проверен откат миграции.
   - **Внешние действия:** создать D1 binding `wrangler d1 create dialog-db`, привязать в `wrangler.toml` как `DB`.
   - **Статус:** ✅ Добавлена миграция `0001_init_dialog_tables.sql` с таблицами `users`, `messages` и индексами по пользователям
     и временным меткам для быстрых выборок контекста.
2. Адаптер `StoragePort` для D1.
   - **Результат:** CRUD-операции сохраняют пользователей и сообщения, `getRecentMessages` возвращает N последних реплик.
   - **Проверка:** тесты с `@cloudflare/workers-types` + `better-sqlite3` (локально) проверяют вставку/чтение и корректный порядок сообщений.
   - **Статус:** ✅ Реализован адаптер `createD1StorageAdapter`, добавлены модульные тесты `apps/worker-main/adapters/d1-storage/__tests__/d1-storage.test.ts`, покрывающие апдейт пользователя, дедупликацию сообщений и выборку истории.
3. Интеграция в композицию.
   - **Результат:** `compose.ts` подключает адаптер при наличии D1 binding, иначе NOOP.
   - **Проверка:** `npm run test -- composition-storage`; отрицательный тест без биндинга возвращает NOOP.
4. Диалоговая память.
   - **Результат:** ядро запрашивает последние N сообщений и передаёт их Responses; сохраняет и исходное, и ответ.
   - **Проверка:** E2E прогон: отправить 3 сообщения, убедиться, что D1 содержит записи (команда запускает `wrangler d1 execute` SELECT и сообщает результат); проверка очистки старых записей при достижении лимита.

**Риски и предохранители:** план миграций без простоя; мониторинг размера базы; перед изменениями схемы выполняется бэкап.

**Критерии приёмки:** данные пишутся в D1, Responses получает контекст, бот отвечает, история доступна.

### Майлстоун 5. Rate Limit Feature
**Цель:** ограничивать количество ответов пользователю в сутки с помощью KV и промптового уведомления.

**Зависимости:** майлстоуны 1–4.

**Шаги и проверки:**
1. KV-хранилище и адаптер `RateLimitPort`.
   - **Результат:** реализация инкремента суточных счётчиков, TTL = 24ч.
   - **Проверка:** юнит-тесты с локальным KV-симулятором (`miniflare`) проверяют достижение лимита и гонки при параллельных запросах.
   - **Внешние действия:** создать KV namespace `wrangler kv:namespace create RATE_LIMIT`, привязать как `RATE_LIMIT_KV`.
   - **Статус:** ✅ Реализован адаптер `createKvRateLimitAdapter`, ключи сегментируются по окнам 24ч, покрыто тестами `apps/worker-main/adapters/kv-rate-limit/__tests__/kv-rate-limit.test.ts`.
2. Фича `features/limits`.
   - **Результат:** middleware блокирует ядро при превышении лимита, отправляет пользователю уведомление, логирует событие с ключевыми полями (`userId`, `limit`, `ttl`).
   - **Проверка:** интеграционный тест с имитацией нескольких запросов; `npm run test -- limits` и проверка логов; метрика отказов лимита доступна в аналитике.
   - **Статус:** ✅ Добавлен нотификатор `createRateLimitNotifier`, роутер вызывает его при ответе `'rate_limited'`, добавлены тесты `apps/worker-main/features/limits/__tests__/rate-limit-notifier.test.ts` и `apps/worker-main/http/__tests__/router.test.ts`.
3. Конфигурация KV-флага.
   - **Результат:** `KV` ключ `LIMITS_ENABLED` включает/отключает middleware без перезагрузки воркера.
   - **Проверка:** ручной тест: переключить ключ через `wrangler kv:key put`, убедиться, что лимит срабатывает/не срабатывает без redeploy; фиксируем задержку распространения.

**Риски и предохранители:** KV недоступен → разрешаем ответ и логируем предупреждение; не храним чувствительные данные; документируем процедуру очистки ключей.

**Критерии приёмки:** лимит блокирует ответы после N сообщений в сутки и легко отключается флагом.

### Майлстоун 6. Export CSV Feature
**Цель:** выгружать диалоги из D1 в CSV по запросу администратора.

**Зависимости:** майлстоуны 1–5.

**Шаги и проверки:**
1. HTTP-роут `/admin/export`.
   - **Результат:** принимает диапазон дат/пагинацию, проверяет `X-Admin-Token`.
   - **Проверка:** юнит-тесты авторизации и валидации входа.
   - **Статус:** ✅ Добавлен конструктор роута `createAdminExportRoute`, проверки реализованы в `apps/worker-main/features/export/__tests__/admin-export-route.test.ts` и интегрированы в HTTP-роутер.
2. CSV-генератор.
   - **Результат:** потоковая генерация CSV (chunked) поверх выборки D1, избегая больших ответов и обеспечивая корректный BOM для Excel.
   - **Проверка:** тест на генерацию >100 записей, проверка памяти (отсутствие утечек) и корректности заголовков; проверяем защиту от CSV-инъекций.
   - **Статус:** ✅ Реализован обработчик `createCsvExportHandler` с потоковой выдачей CSV, BOM и защитой от CSV-инъекций; покрыт тестами `apps/worker-main/features/export/__tests__/csv-export.test.ts`.
3. Внешняя проверка.
   - **Внешние действия:** команда выполняет `curl -H "X-Admin-Token: ..." https://<worker>/admin/export?from=...` и подтверждает получение корректного CSV; проверяется заголовок `Content-Type: text/csv; charset=utf-8`.
   - **Статус:** ⏳ Требуется ручная проверка после деплоя (curl-запрос под админ-токеном, подтверждение заголовков и содержимого).

**Риски и предохранители:** ограничение выгрузки пагинацией и валидацией диапазонов; токен не логируется; большая выгрузка переводится в очередь.

**Критерии приёмки:** админ может скачать CSV, формат совместим с Excel, запрос защищён токеном.

### Майлстоун 7. Broadcast Feature
**Цель:** ручная рассылка сообщений пользователям с соблюдением лимитов Telegram.

**Зависимости:** майлстоуны 1–6.

**Шаги и проверки:**
1. Маршрут `/admin/broadcast` и очередь отправок.
   - **Результат:** эндпоинт принимает текст/фильтры, инициирует рассылку через воркер (пакетная отправка + троттлинг), возвращает оператору идентификатор задания.
   - **Проверка:** юнит-тесты проверяют валидацию, формирование задания и старт рассылки; негативный тест на повторный запуск с тем же `jobId`.
2. Планировщик отправок.
   - **Результат:** модуль очереди (на старте — in-memory, затем опционально Cloudflare Queues) обрабатывает пачки с задержками, уважая лимиты и гарантируя идемпотентность по jobId.
   - **Проверка:** тесты симулируют массовую рассылку, проверяют обработку `429`, повторов и идемпотентность; прогресс задания сохраняется в KV.
3. Внешние действия.
   - **Внешние действия:**
     - Настроить KV-флаг `BROADCAST_ENABLED`.
     - (Опционально) создать Queue `wrangler queues create broadcast-queue` и привязать.
   - **Проверка:** команда запускает тестовую рассылку на 2–3 пользователей и подтверждает получение сообщений без ошибок в логах; проверяется возможность ручной остановки.

**Риски и предохранители:** запрет пустых сообщений; защита от дубликатов при рестарте; ограничение размера рассылки и мониторинг ошибок.

**Критерии приёмки:** рассылка отправляется, соблюдая троттлинг, при ошибках отдельные пользователи пропускаются без падения ядра.

### Майлстоун 8. Observability & Operations
**Цель:** обеспечить мониторинг, алерты и устойчивость к сбоям.

**Зависимости:** майлстоуны 1–7.

**Шаги и проверки:**
1. Логирование и трассировка.
   - **Результат:** единый логгер в `shared/` с уровнями (info/warn/error) и контекстом (requestId, userId); интеграция с `wrangler tail`.
   - **Проверка:** `npm run test -- logger` и ручная проверка логов; персональные данные маскируются.
2. Метрики и алерты.
   - **Результат:** экспорт технических метрик (ответы, ошибки, латентность) в Workers Analytics Engine или сторонний сервис; определены алерты по ключевым SLA.
   - **Проверка:** отчёт команды о появлении метрик в панели; автоматический smoke-тест подтверждает отправку метрик; алерты тестируются через понижение порога.
3. Операционные инструкции.
   - **Результат:** документы в `memory-bank/` с инструкциями по обновлению ассистента, ротации секретов, процедурам инцидентов; указаны контакты on-call и частота ревизии.
   - **Проверка:** ревью содержимого, подтверждение команды; чек-лист подписан ответственными лицами.

**Риски и предохранители:** регулярные учения по инцидентам; уведомление on-call о любых изменениях; метрики покрывают все критичные сценарии.

**Критерии приёмки:** логи и метрики доступны, документация покрывает стандартные операции.

### Майлстоун 9. Post-MVP Enhancements (опциональный backlog)
**Цель:** подготовить пространство для расширения (например, .xlsx, мультиязычность, очереди).

**Идеи и проверки:**
- Экспорт `.xlsx` через очередь и R2.
- Автономное тестирование промптов Responses.
- Сегментация пользователей для рассылок.
Каждый пункт потребует отдельной декомпозиции перед стартом.

## Журнал прогресса
- 2025-10-23: Инициализирована дорожная карта и создан каталог памяти (этап текущей сессии).
- 2025-10-23: Обновлена структура и правила дорожной карты.
- 2025-10-23: Сформирована детальная дорожная карта с майлстоунами 1–9.
- 2025-10-24: Дорожная карта уточнена: устранены дубликаты, уточнены проверки и результаты шагов.
- 2025-10-24: Проведён критический анализ рисков, усилены проверки и предохранители по всем майлстоунам.
- 2025-10-24: Добавлены процедуры синхронизации ветки и проверки конфликтов перед PR.
- 2025-10-24: Реализован контур `DialogEngine`, определены контракты портов, подготовлены юнит-тесты (ожидают установки зависимостей npm).
- 2025-10-24: Подготовлен Telegram-парсер вебхука, команды `/admin*` обрабатываются до ядра, покрыто юнит-тестами `http/telegram-webhook`.
- 2025-10-24: Реализован адаптер Telegram messaging с ретраями и модульными тестами `apps/worker-main/adapters/telegram/__tests__/messaging.test.ts`.
- 2025-10-24: Настроен менеджер typing-индикации, роутер вызывает его перед ядром, добавлены тесты `apps/worker-main/http/__tests__/typing-indicator.test.ts`.
- 2025-10-24: Добавлен адаптер OpenAI Responses с таймаутами, ретраями и фильтрацией управляющих символов; написаны тесты `apps/worker-main/adapters/openai-responses/__tests__/openai-responses.test.ts`.
- 2025-10-24: Подготовлена стартовая миграция D1 `0001_init_dialog_tables.sql` с таблицами пользователей и сообщений.
- 2025-10-24: Реализован адаптер `createD1StorageAdapter` для Cloudflare D1 с модульными тестами `apps/worker-main/adapters/d1-storage/__tests__/d1-storage.test.ts`.
- 2025-10-24: Настроен KV-флаг `LIMITS_ENABLED` для гибкого отключения лимитов, добавлены обёртки и тесты `apps/worker-main/features/limits`.
- 2025-10-24: Добавлен KV-адаптер лимитов `createKvRateLimitAdapter` с TTL 24 часа и юнит-тестами `apps/worker-main/adapters/kv-rate-limit/__tests__/kv-rate-limit.test.ts`.
- 2025-10-24: Реализован нотификатор лимита `createRateLimitNotifier`, HTTP-роутер рассылает предупреждения и покрыт тестами `apps/worker-main/features/limits/__tests__/rate-limit-notifier.test.ts`, `apps/worker-main/http/__tests__/router.test.ts`.
- 2025-10-24: Добавлен админ-роут `/admin/export`, реализован потоковый CSV-генератор, обновлены тесты HTTP и экспорт-фичи.

## Быстрый протокол действий
1. Проверить ветку и статус репозитория.
2. Ознакомиться с `RoadMap.md` и памятками в `memory-bank/`.
3. Составить микроплан и выполнить изменения ограниченной партией.
4. Запустить проверки, просмотреть изменения, обновить журнал и памятки.
5. Убедиться в чистоте истории: `git status`, `git diff --check`, разрешение конфликтов фиксируется в журнале.
6. Закоммитить изменения, подготовить PR через `make_pr`.
7. Отчёт о выполнении задачи всегда предоставляй на русском языке.
8. В отчёте указывай прогресс-бар с процентом пройденного пути, целью ближайшего майлстоуна и количеством задач до него.
