# RoadMap

## Контекст и цели
- Репозиторий `tg-responcer` управляется по базовому протоколу из `Protocol.md`.

- Дорожная карта служит единственным источником истины о шагах, проверках и состоянии создания Telegram-бота на OpenAI Responses через Cloudflare Workers.
- **Цель проекта:** собрать устойчивого Telegram-бота с модульной архитектурой: базовый диалоговый контур (ядро + память), выгрузка диалогов, ручные рассылки, лимиты на ответы и индикация `typing…`. Промпты и инструменты настраиваются в OpenAI Responses, код работает через `/v1/responses`, указывая `model` и при необходимости опубликованный `prompt.id` (`pmpt_…`).

## Принципы работы
1. Следовать протоколу: поддерживать артефакты `RoadMap.md` и `memory-bank/`, хранить логи/снапшоты вне git.
2. Работать партиями до ≈150 файлов, контролировать `git diff --stat`, выполнять проверки после каждой партии.
3. Каждый подпункт дорожной карты завершать отдельным коммитом и фиксировать прогресс здесь.
4. Поддерживать линейность истории ветки `work`, избегать расходящихся коммитов.
5. Перед началом задачи сверяться с архитектурой, рисками и актуальной картиной системы.
6. Перед подготовкой PR синхронизировать ветку `work` с целевой базой, убедиться в отсутствии merge-конфликтов и зафиксировать
   в журнале, если конфликт решался вручную.

## Анализ рисков и допущений

- **Инфраструктура.** Предполагается доступ к Cloudflare Workers, KV, D1, Queues, Telegram Bot API и OpenAI Responses. Любые изменения тарифов или API требуют синхронизации с владельцем продукта до начала работ.
- **Безопасность секретов.** Все секреты заносятся через `wrangler secret`, не хранятся в репозитории и обновляются по чек-листу из `memory-bank/`.
- **Релизы.** Единственный способ деплоя — `wrangler deploy` из проверенной ветки `work` с тегированием релизов. Hotfix вне дорожной карты фиксируется в журнале прогресса отдельной записью.
- **Окна недоступности.** Любые миграции D1 или крупные рассылки согласуются заранее; при необходимости паузы в приёме вебхуков включается maintenance-флаг в KV и уведомляется команда.
- **Внешние зависимости.** Telegram и OpenAI могут возвращать недокументированные ошибки — каждая точка вызова должна иметь защиту таймаутом, повтором и fallback-сообщением.

Пока допущения выполняются, дорожная карта остаётся валидной. При нарушении допущения шаг пересматривается до начала реализации.

## Структура

**Цель:** устойчивый диалоговый контур с возможностью подключать апгрейды (экспорт, рассылка, лимиты) без изменений и рисков для базы.

**Слои и их роли:**
- **Ядро (`core/`)** — последовательность шагов диалога (лимит → запись → ответ ИИ → запись → отправка). Никаких SDK/HTTP. Статус: **FROZEN**.
- **Порты (`ports/`)** — четыре стабильных интерфейса: `MessagingPort` (`sendTyping`, `sendText`), `AiPort` (`reply({ userId, text, context }) → { text }`), `StoragePort` (`saveUser`, `appendMessage`, `getRecentMessages`), `RateLimitPort` (`checkAndInc → "ok" | "limit"`).
- **Адаптеры (`adapters/*`)** — реализации портов (Telegram, OpenAI Responses, D1, KV и т.п.).
- **NOOP-адаптеры (`adapters-noop/*`)** — безопасные заглушки для каждого порта по умолчанию.
- **Композиция (`composition/`)** — сборка адаптеров, регистрация фич и чтение KV-флагов.
- **HTTP (`http/`)** — только роутинг: `POST /webhook/:secret` (включая обработку команд/админа до ядра), `GET /healthz`, `/admin/*` (роуты фич).
- **Фичи (`features/*`)** — апгрейды как отдельные модули (экспорт CSV, рассылка, лимиты). Подключаются через `composition/register-features.ts` в `try/catch`; при сбое ядро остаётся рабочим.

**Инварианты Responses:**
- Воркёр вызывает только `POST https://api.openai.com/v1/responses` с явным `model` из `env.OPENAI_MODEL`; при необходимости использует опубликованный `prompt.id` (`pmpt_…`) и переменные.
- Ассистентские идентификаторы (`asst_…`) не используются; состояние продолжений храним через `previous_response_id`.
- При ответе показываем `typing…`, затем отправляем финальное сообщение.
- Контекст для модели — короткий хвост из `StoragePort.getRecentMessages`, передаваемый через поле `input`.

**Хранилища и флаги:**
- Диалоги и пользователи — Cloudflare D1 (Paid до 10 ГБ, Free до 500 МБ).
- Лимиты и фич-флаги — Cloudflare KV (`STREAMING`, `BROADCAST`, `EXPORT_ENABLED`, `LIMITS_ENABLED` и др.).
- Админ-доступ: `/admin/*` через заголовок `X-Admin-Token`, чат-команды — whitelist `ADMIN_IDS`.

**Технические предохранители:** `CODEOWNERS` на `/core` и `/ports`, CI-гард, eslint-правила против сквозных импортов, ручной чек-лист релиза в `memory-bank/operations.md`.

## Целевая архитектура после перехода на Responses-only

- **AI-контур.** Адаптер `adapters/openai-responses` формирует запросы в `/v1/responses`, пробрасывая `model`, `input` и, при наличии, `prompt.id` с переменными. Для продолжений используется `previous_response_id`, а ответы читаются из `output_text` и item-потока.
- **Конфигурация окружения.** Воркёр ожидает `OPENAI_API_KEY`, `OPENAI_MODEL`, опционально `OPENAI_PROMPT_ID` (`pmpt_…`) и `OPENAI_PROMPT_VARIABLES` (JSON). Переменные валидируются и логируются без секретов.
- **Совместимость модулей.** Все активные адаптеры и фичи должны опираться на `PromptConfig`/`ResponseConfig` вместо `AssistantConfig`; legacy-поля `assistantId` вычищаются или закрываются фич-флагами до миграции.
- **Контроль рисков.** Перед подключением новых модулей выполняется проверка влияния на ядро и текущую рабочую связку Telegram ↔ ядро ↔ Responses.

## Правила
1. **FROZEN CORE.** `core/` меняем только с bump `core/VERSION` и ревью владельца.
2. **Стабильные порты.** Сигнатуры в `ports/` неизменны без версионирования и ревью.
3. **Только через порты.** Ядро не импортирует SDK, HTTP или биндинги Cloudflare.
4. **Команды до ядра.** `/admin`, `/broadcast` и служебные команды обрабатываются в `http/`, а не в `DialogEngine`.
5. **Фичи не трогают ядро.** Новые функции живут в `features/*` и подключаются через `composition/` под KV-флаги.
6. **NOOP по умолчанию.** При отсутствии адаптера/фичи используется заглушка, диалог остаётся работоспособным.
7. **Промпты вне кода.** Настройки Responses живут в опубликованных промптах; код читает `env.OPENAI_MODEL` и опционально `env.OPENAI_PROMPT_ID`/`PROMPT_VARIABLES`.
8. **Админ-охранник.** `/admin/*` требует `X-Admin-Token`; чат-команды доступны только `ADMIN_IDS`.
9. **Мягкая деградация.** Внешние вызовы защищены `try/catch` и таймаутами, ошибки логируем без остановки ядра.
10. **Троттлинг и лимиты.**
    - Применяется к массовым отправкам (рассылки, циклы). Обычные ответы ядра не троттлим.
    - Лимиты Telegram: ≤30 сообщений/сек глобально, ≤1 сообщение/сек в личный чат, ≤20 сообщений/мин в группы/каналы.
    - При `429 Too Many Requests` читаем `retry_after`, ждём указанное время, используем экспоненциальную задержку с джиттером, не более трёх ретраев, затем логируем и пропускаем адресата.
    - Отправляем батчами с паузами, порядок внутри батча не критичен.
    - При росте объёмов выносим рассылки в Cloudflare Queues (ретраи, батч-обработка) без изменений ядра.
11. **Тесты-сторожа.** Контракты портов, смоук `/webhook` с моками, проверка отключённых фич.
12. **Guardrails в репо.** `CODEOWNERS`, CI-гард и eslint обеспечивают замороженное ядро и корректные импорты.
13. **Retain & Rotate.** Политика хранения диалогов, крупные выгрузки — CSV с пагинацией или очередями.
14. **Флаги — источник правды.** Подключение/отключение фич происходит через KV и `composition/`.

## Майлстоуны проекта

### Майлстоун 0. Операционная система управления проектом *(завершён 2025-10-23)*
**Цель:** зафиксировать протокол, дорожную карту и структуру памяти.

**Шаги и проверки:**
1. Создать `RoadMap.md`, каталог `memory-bank/`, зафиксировать журнал.
   - **Результат:** артефакты операционной системы присутствуют.
   - **Проверка:** `ls` показывает файлы; дорожная карта описывает цели и принципы.
2. Настроить контроль линейности ветки и журнал прогресса.
   - **Результат:** описаны меры контроля истории ветки и рисков.
   - **Проверка:** раздел «Принципы работы» отражает правила линейности.

**Риски и предохранители:** убедиться, что нет других файлов с конфликтующими инструкциями; зафиксировать ссылку на протокол в `memory-bank/`.

**Критерий приёмки:** RoadMap и память созданы, правила зафиксированы.

### Майлстоун 1. Responses-only Alignment & Baseline Verification
**Цель:** перестроить план работ под архитектуру `Responses + PromptID`, собрать проверки для действующих модулей и зафиксировать риски будущих подключений.

**Зависимости:** майлстоун 0.

**Шаги и проверки:**
1. Каталог проверок активной связки (ядро ↔ Telegram ↔ Responses).
   - **Результат:** в RoadMap и `memory-bank` зафиксирован перечень обязательных проверок/исправлений для модулей, уже задействованных в продовой связке. Список включает:
     - `core/DialogEngine` и `ports/*` — валидация отсутствия прямых зависимостей от `assistantId`, проверка последовательности вызовов.
     - `adapters/telegram` и `http/telegram-webhook` — smoke-тесты маршрутов, актуальность команд до ядра, контроль `typing`.
     - `adapters/openai-responses` — миграция на `PromptConfig`, проверка `env.OPENAI_MODEL/OPENAI_PROMPT_ID`, логирование `response_id`.
     - `composition/*` и `features/typing` — корректная сборка зависимостей, проверка KV-флагов.
     - Конфигурация окружения — наличие секретов, формат `pmpt_…`, trim значений.
   - **Проверка:** ревью RoadMap подтверждает наличие списка; в отчётах по шагам фиксируем прогресс и количество оставшихся проверок до закрытия майлстоуна.
   - **Статус:** ✅ Проведена сверка активных модулей: ядро и порты используют только `model`/контекст без `assistantId`, HTTP-роутер обрабатывает команды до ядра, Telegram-адаптер подтверждён тестами `messaging.test.ts`, а `adapters/openai-responses` логирует `response_id` и `prompt`. Проверки сведены в `memory-bank/active-stack-checks.md`, прогон `npm test` подтверждает целостность цепочки.
2. Проверка изоляции модулей, не участвующих в текущем контуре.
   - **Результат:** проведён аудит зависимостей между активными модулями и заготовками. Проверяются:
     - `features/limits`, `features/export`, `features/broadcast` на отсутствие импортов `adapters/openai-responses` и воздействия на текущую связку.
     - `adapters-noop/*`, `composition/register-features.ts` на корректные фич-флаги.
     - Тестовые файлы на отсутствие жёстких ссылок `assistantId`.
   - При наличии влияния добавляются временные флаги/заглушки или заводится «Задача-торможение».
   - **Проверка:** в RoadMap отмечены результаты аудита; при обнаружении связей открываются подзадачи с указанием файлов и требуемых фиксов.
   - **Статус:** ✅ Аудит изоляции выполнен: `features/limits` и `features/export` используют только порты и утилиты без прямых зависимостей от `adapters/openai-responses`, `adapters-noop` и `composition/compose.ts` не подтягивают Responses-функциональность по умолчанию, тестовые файлы не содержат ссылок на `assistantId`. Итоги сведены в `memory-bank/module-isolation-audit.md`, блокеров не обнаружено, `features/broadcast` ещё не реализована и остаётся под наблюдением на будущих шагах.
3. План ревизии модулей для будущих подключений.
   - **Результат:** составлен список модулей, требующих адаптации под `PromptID`, включая:
     - `adapters/d1-storage`, `features/export` — проверка формата сообщений и хранения `response_id`.
     - `features/limits`, `adapters/kv-rate-limit` — исключение ссылок на `assistantId`, согласование уведомлений с Responses.
     - `features/broadcast`, планируемые очереди — использование Responses без ассистента.
     - `features/observability`, `admin`-диагностика — обновление метрик/роутов под новую конфигурацию env.
   - Для каждого элемента описаны риски и проверки, которые нужно выполнить перед активацией.
   - **Проверка:** запись добавлена в журнал прогресса и памятки (`memory-bank/infrastructure.md`, `memory-bank/stable-builds.md`); наличие незакрытых проверок помечается как блокер для команды «Следуй дорожной карте».
   - **Статус:** ✅ План составлен: перечислены `adapters/d1-storage`, `features/export`, `features/limits`/`adapters/kv-rate-limit`, `features/broadcast`, `features/observability` и документация. Для каждого модуля описаны риски (потеря `response_id`, отсутствие троттлинга, устаревшие метрики) и проверки перед активацией. Детали перенесены в `memory-bank/infrastructure.md` и `memory-bank/stable-builds.md`, незакрытые проверки помечены как блокеры до апдейтов.
4. Обновление быстрой инструкции и мемори-банка под Responses-only.
   - **Результат:** `RoadMap.md` и памятки отражают новые правила: отказ от `assistantId`, требования к `OPENAI_MODEL`/`OPENAI_PROMPT_ID`, механизм «Задачи-торможения» при пропущенных критичных проверках.
   - **Проверка:** ревью документов подтверждает наличие инструкции; быстрый протокол содержит пункт о создании задачи-торможения и отчётности по проверкам.
   - **Статус:** ✅ RoadMap и памятки обновлены: быстрый протокол дополнен проверкой требований Responses-only, `memory-bank/README.md` фиксирует отказ от `assistantId` и правила валидации `OPENAI_MODEL`/`OPENAI_PROMPT_ID`.

**Риски и предохранители:** контролировать размер диффов (<200 строк), согласовывать изменения плана с владельцем продукта, не переходить к коду до утверждения списка проверок.

**Критерии приёмки:** RoadMap и память отражают новую архитектуру, список проверок утверждён, блокеры для будущих модулей задокументированы.

### Майлстоун 2. Frozen Core Scaffold
**Цель:** подготовить каркас воркера с замороженным ядром и портами, чтобы дальнейшие апгрейды подключались без риска.

**Зависимости:** майлстоуны 0–1.

**Шаги и проверки:**
1. Стартовая структура воркера.
   - **Результат:** каталоги `apps/worker-main/{core,ports,adapters,adapters-noop,composition,http,features,shared}` с базовыми индексами и заглушечными `index.ts`/`README` для ориентирования.
   - **Проверка:** `tree apps/worker-main -L 2` показывает структуру (в CI допускается `find apps/worker-main -maxdepth 2 -type d`).
   - **Внешние действия:** не требуются.
   - **Статус:** ✅ Каркас каталогов и заглушки созданы, структура соответствует плану.
2. Реализация `core/DialogEngine.ts` и контрактов.
   - **Результат:** минимальный контур диалога вызывает порты в последовательности «лимит → запись входа → ответ ИИ → запись ответа → отправка», интерфейсы экспортируются из `ports/`, файл помечен баннером FROZEN.
   - **Проверка:** юнит-тест `DialogEngine` с моками (`npm run test:core`) покрывает порядок вызовов и обработку ошибок; отчёт о покрытии сохраняется в `logs/`.
   - **Статус:** ✅ Контур реализован, тесты подготовлены (`vitest`). Запуск ожидает установки npm-зависимостей (в среде агента `npm install` завершился ошибкой 403).
3. Определение портов и NOOP-адаптеров.
   - **Результат:** интерфейсы для Messaging/Ai/Storage/RateLimit и заглушки, возвращающие безопасные значения и логирующие предупреждения, чтобы облегчить отладку; JSDoc поясняет контракт по таймингам и повторам.
   - **Проверка:** `npm run typecheck` проходит; unit-тесты NOOP подтверждают отсутствие побочных эффектов; eslint-правило запрещает прямые импорты в `core/`.
   - **Статус:** ✅ Контракты уточнены, заглушки реализованы, добавлены юнит-тесты (запуск тестов ожидает доступа к npm registry, `npm install` возвращает 403).
4. Композиция и HTTP-роутер.
   - **Результат:** `composition/compose.ts` выбирает адаптеры или NOOP в зависимости от доступных биндингов, `http/router.ts` объявляет `/webhook/:secret` и `/healthz`, webhook проверяет секрет и проксирует в `DialogEngine`.
   - **Проверка:** интеграционный тест с моками (`npm run test -- http-router`), ручной вызов `wrangler dev` + `curl /healthz` (сообщить результат); лог или скриншот команды сохраняется в `logs/`.
   - **Статус:** ✅ Реализованы композиция и HTTP-роутер с покрытием unit-тестами (`apps/worker-main/http/__tests__/router.test.ts`, `apps/worker-main/composition/__tests__/compose.test.ts`); роут `/healthz` возвращает `status: ok`, webhook валидирует секрет и проксирует вызов в `DialogEngine`.
5. Guardrails.
   - **Результат:** `CODEOWNERS`, CI-гард (GitHub Actions), eslint-правила запретов импортов, файл `core/VERSION` и скрипт `npm run validate-guards`, который срабатывает при изменении `core/` без bump версии.
   - **Проверка:** `npm run lint` без ошибок; `npm run validate-guards` отрабатывает без сбоев; визуальная проверка `CODEOWNERS`; вручную симулируем изменение в `core/` без bump и убеждаемся, что guard падает.
   - **Статус:** ✅ Добавлены `CODEOWNERS`, workflow CI (lint, test, validate-guards), правило `no-restricted-imports` и файл `core/VERSION`; guard скрипт блокирует изменения ядра без bump (локальный запуск требует `npm install`, которое в среде агента даёт 403 на npm registry).

**Риски и предохранители:** закрепить владельцев `core/` и `ports/`; проверять, что адаптеры не импортируют `core/` напрямую; хранить скриншоты запусков проверок.

**Критерии приёмки:** структура собирается `npm run build`, тесты проходят, CI-гарды действуют. Внешняя команда подтверждает, что `wrangler dev` запускается и `/healthz` отвечает 200.

### Майлстоун 3. Telegram Webhook & Messaging Adapter
**Цель:** приём обновлений Telegram, показ `typing…`, отправка ответов через адаптер, команды обрабатываются до ядра.

**Зависимости:** майлстоуны 1–2.

**Шаги и проверки:**
1. Telegram-парсер апдейтов и роут вебхука.
   - **Результат:** `http/telegram-webhook.ts` валидирует секрет, извлекает текстовые сообщения, команды `/admin*` направляет в фичи без обращения к ядру.
   - **Проверка:** юнит-тесты на разных видах апдейтов (`npm run test -- telegram-webhook`) и проверка, что неверный секрет отвергается; негативные тесты на отсутствующие поля и нестандартные апдейты.
   - **Статус:** ✅ Реализован парсер Telegram-апдейтов, команды `/admin*` перенаправляются в фичи, добавлены модульные тесты и расширен HTTP-роутер для раннего завершения запроса.
2. Messaging адаптер.
   - **Результат:** `adapters/telegram` реализует `MessagingPort` (`sendTyping`, `sendText`) через `fetch` Telegram API, учитывает chat_id и возможные ошибки API.
   - **Проверка:** мок-тесты адаптера, подтверждающие корректное формирование запросов и разбор `retry_after`; нагрузочный тест на серию из 10 сообщений выявляет троттлинг-ошибки.
   - **Статус:** ✅ Добавлен адаптер `createTelegramMessagingAdapter` с ретраями, очисткой текста и поддержкой `retry_after`; покрыт модульными тестами на happy-path и ошибки.
3. Конфигурация секретов и деплой.
   - **Внешние действия:**
     - В Wrangler: `wrangler secret put TELEGRAM_BOT_TOKEN`.
     - Настроить `TELEGRAM_WEBHOOK_SECRET` (для URL).
     - Установить вебхук командой `curl https://api.telegram.org/bot<TOKEN>/setWebhook` на `https://<worker>/webhook/<secret>`.
   - **Проверка:** после деплоя отправить тестовое сообщение, сообщить агенту payload и ответ; `wrangler tail` без ошибок; в журнале прогресса фиксируем время и результат ручного теста.
4. Typing-индикация.
   - **Результат:** воркер вызывает `sendTyping` до обращения к ядру и завершает после ответа; повторные сообщения не запускают параллельных `sendTyping`.
   - **Проверка:** в Telegram клиенте видна индикация typing перед ответом; подтверждение от команды, лог показывает корректные вызовы; автоматический тест имитирует долгий ответ ИИ и проверяет отключение typing.
   - **Статус:** ✅ Добавлен менеджер typing-индикации, `createTypingIndicator` запускает `sendTyping` до вызова ядра и предотвращает
     параллельные индикаторы; покрыто юнит-тестами (`typing-indicator.test.ts`, `router.test.ts`).

**Риски и предохранители:** не логировать секреты; обработать команды `/start` и сервисные сообщения; мониторить `wrangler tail` на неожиданные типы апдейтов.

**Критерии приёмки:** вручную проверено, что сообщение из Telegram проходит через воркер, вызывает NOOP-AI и возвращает заглушечный ответ, а команды `/admin` не пробрасываются в ядро.

### Майлстоун 4. OpenAI Responses Integration
**Цель:** подключить OpenAI Responses как источник ответов, используя REST `/v1/responses` без стриминга.

**Зависимости:** майлстоуны 1–3.

**Шаги и проверки:**
1. Адаптер `AiPort` для Responses.
   - **Результат:** `adapters/openai-responses` формирует запрос `POST https://api.openai.com/v1/responses` с явным `model`, контекстом из `input` и, при наличии, `prompt: { id: pmpt_…, variables }`; поддерживает `previous_response_id` и разбирает `output_text`/items.
   - **Проверка:** юнит-тесты с `fetch-mock` проверяют тело запроса (без `assistant_id`), обработку переменных промпта, таймаут и ретраи; `npm run test -- openai-adapter`; лог содержит `response_id`.
   - **Статус:** ✅ Миграция завершена: адаптер использует `model`/`prompt.id`, парсит `output_text` и `items`, восстанавливает `previous_response_id` из контекста, а тесты `apps/worker-main/adapters/openai-responses/__tests__/openai-responses.test.ts` подтверждают отсутствие `assistantId` и корректный разбор ответа.
   - **Обновление:** памятка [memory-bank/openai-responses-prompt.md](memory-bank/openai-responses-prompt.md) дополнена фактами по ретраям и `previous_response_id` (см. журнал 2025-10-27).
2. Конфигурация секретов.
   - **Внешние действия:**
     - `wrangler secret put OPENAI_API_KEY`.
     - `wrangler secret put OPENAI_MODEL`.
     - (опционально) `wrangler secret put OPENAI_PROMPT_ID`, `wrangler secret put OPENAI_PROMPT_VARIABLES`.
   - **Проверка:** пробный вызов `wrangler dev` с тестовым запросом; лог подтверждает использование `model` и корректный разбор `prompt.id`; секреты не попадают в stdout.
3. Интеграция с ядром.
   - **Результат:** `DialogEngine` через порт получает ответ, передаёт `output_text` адаптеру Telegram, fallback остаётся прозрачным для ядра; `previous_response_id` сохраняется для последующих вызовов.
   - **Проверка:** E2E тест через `wrangler dev` с отправкой сообщения; лог содержит `response_id`, `previous_response_id` и усечённый текст ответа; тестовое окружение использует зашифрованные переменные.
4. Обработка деградаций.
   - **Результат:** при ошибке Responses бот отправляет запасной ответ и логирует ошибку с requestId, ядро не падает.
   - **Проверка:** тест с симулированным `500` (мок) проверяет fallback; команда подтверждает, что Telegram ответ содержит дружелюбное сообщение об ошибке; метрика ошибок Responses инкрементируется с пометкой `ai_response_failure`.

**Риски и предохранители:** таймаут ≤20 с на запрос Responses; не логировать персональные данные; мониторить количество повторов.

**Критерии приёмки:** бот отвечает реальным текстом от Responses, fallback работает, секреты заданы.

### Майлстоун 5. D1 Persistence & Диалоговая память
**Цель:** хранить пользователей и историю диалогов в D1, предоставлять короткий контекст ядру.

**Зависимости:** майлстоуны 1–4.

**Шаги и проверки:**
1. Схема базы и миграции.
   - **Результат:** SQL миграции для таблиц `users`, `messages` (user_id, role, content, timestamps, metadata).
   - **Проверка:** `wrangler d1 execute <DB> --file=...` создаёт таблицы без ошибок; локально проверен откат миграции.
   - **Внешние действия:** создать D1 binding `wrangler d1 create dialog-db`, привязать в `wrangler.toml` как `DB`.
   - **Статус:** ✅ Добавлена миграция `0001_init_dialog_tables.sql` с таблицами `users`, `messages` и индексами по пользователям
     и временным меткам для быстрых выборок контекста.
2. Адаптер `StoragePort` для D1.
   - **Результат:** CRUD-операции сохраняют пользователей и сообщения, `getRecentMessages` возвращает N последних реплик.
   - **Проверка:** тесты с `@cloudflare/workers-types` + `better-sqlite3` (локально) проверяют вставку/чтение и корректный порядок сообщений.
   - **Статус:** ✅ Реализован адаптер `createD1StorageAdapter`, добавлены модульные тесты `apps/worker-main/adapters/d1-storage/__tests__/d1-storage.test.ts`, покрывающие апдейт пользователя, дедупликацию сообщений и выборку истории.
3. Интеграция в композицию.
   - **Результат:** `compose.ts` подключает адаптер при наличии D1 binding, иначе NOOP.
   - **Проверка:** `npm run test -- composition-storage`; отрицательный тест без биндинга возвращает NOOP.
4. Диалоговая память.
   - **Результат:** ядро запрашивает последние N сообщений и передаёт их Responses; сохраняет и исходное, и ответ.
   - **Проверка:** E2E прогон: отправить 3 сообщения, убедиться, что D1 содержит записи (команда запускает `wrangler d1 execute` SELECT и сообщает результат); проверка очистки старых записей при достижении лимита.

**Риски и предохранители:** план миграций без простоя; мониторинг размера базы; перед изменениями схемы выполняется бэкап.

**Критерии приёмки:** данные пишутся в D1, Responses получает контекст, бот отвечает, история доступна.

### Майлстоун 6. Rate Limit Feature
**Цель:** ограничивать количество ответов пользователю в сутки с помощью KV и промптового уведомления.

**Зависимости:** майлстоуны 1–5.

**Шаги и проверки:**
1. KV-хранилище и адаптер `RateLimitPort`.
   - **Результат:** реализация инкремента суточных счётчиков, TTL = 24ч.
   - **Проверка:** юнит-тесты с локальным KV-симулятором (`miniflare`) проверяют достижение лимита и гонки при параллельных запросах.
   - **Внешние действия:** создать KV namespace `wrangler kv:namespace create RATE_LIMIT`, привязать как `RATE_LIMIT_KV`.
   - **Статус:** ✅ Реализован адаптер `createKvRateLimitAdapter`, ключи сегментируются по окнам 24ч, покрыто тестами `apps/worker-main/adapters/kv-rate-limit/__tests__/kv-rate-limit.test.ts`.
2. Фича `features/limits`.
   - **Результат:** middleware блокирует ядро при превышении лимита, отправляет пользователю уведомление, логирует событие с ключевыми полями (`userId`, `limit`, `ttl`).
   - **Проверка:** интеграционный тест с имитацией нескольких запросов; `npm run test -- limits` и проверка логов; метрика отказов лимита доступна в аналитике.
   - **Статус:** ✅ Добавлен нотификатор `createRateLimitNotifier`, роутер вызывает его при ответе `'rate_limited'`, добавлены тесты `apps/worker-main/features/limits/__tests__/rate-limit-notifier.test.ts` и `apps/worker-main/http/__tests__/router.test.ts`.
3. Конфигурация KV-флага.
   - **Результат:** `KV` ключ `LIMITS_ENABLED` включает/отключает middleware без перезагрузки воркера.
   - **Проверка:** ручной тест: переключить ключ через `wrangler kv:key put`, убедиться, что лимит срабатывает/не срабатывает без redeploy; фиксируем задержку распространения.

**Риски и предохранители:** KV недоступен → разрешаем ответ и логируем предупреждение; не храним чувствительные данные; документируем процедуру очистки ключей.

**Критерии приёмки:** лимит блокирует ответы после N сообщений в сутки и легко отключается флагом.

### Майлстоун 7. Export CSV Feature
**Цель:** выгружать диалоги из D1 в CSV по запросу администратора.

**Зависимости:** майлстоуны 1–6.

**Шаги и проверки:**
1. HTTP-роут `/admin/export`.
   - **Результат:** принимает диапазон дат/пагинацию, проверяет `X-Admin-Token`.
   - **Проверка:** юнит-тесты авторизации и валидации входа.
   - **Статус:** ✅ Добавлен конструктор роута `createAdminExportRoute`, проверки реализованы в `apps/worker-main/features/export/__tests__/admin-export-route.test.ts` и интегрированы в HTTP-роутер.
2. CSV-генератор.
   - **Результат:** потоковая генерация CSV (chunked) поверх выборки D1, избегая больших ответов и обеспечивая корректный BOM для Excel.
   - **Проверка:** тест на генерацию >100 записей, проверка памяти (отсутствие утечек) и корректности заголовков; проверяем защиту от CSV-инъекций.
   - **Статус:** ✅ Реализован обработчик `createCsvExportHandler` с потоковой выдачей CSV, BOM и защитой от CSV-инъекций; покрыт тестами `apps/worker-main/features/export/__tests__/csv-export.test.ts`.
3. Внешняя проверка.
   - **Внешние действия:** команда выполняет `curl -H "X-Admin-Token: ..." https://<worker>/admin/export?from=...` и подтверждает получение корректного CSV; проверяется заголовок `Content-Type: text/csv; charset=utf-8`.
   - **Статус:** ⏳ План внешней проверки подготовлен (`memory-bank/external-checks/admin-export-verification.md`), требуется выполнить ручную проверку после деплоя.

**Риски и предохранители:** ограничение выгрузки пагинацией и валидацией диапазонов; токен не логируется; большая выгрузка переводится в очередь.

**Критерии приёмки:** админ может скачать CSV, формат совместим с Excel, запрос защищён токеном.

### Майлстоун 8. Broadcast Feature
**Цель:** ручная рассылка сообщений пользователям с соблюдением лимитов Telegram.

**Зависимости:** майлстоуны 1–7.

**Шаги и проверки:**
1. Маршрут `/admin/broadcast` и очередь отправок.
   - **Результат:** эндпоинт принимает текст/фильтры, инициирует рассылку через воркер (пакетная отправка + троттлинг), возвращает оператору идентификатор задания.
   - **Проверка:** юнит-тесты проверяют валидацию, формирование задания и старт рассылки; негативный тест на повторный запуск с тем же `jobId`.
   - **Статус:** ✅ Добавлены in-memory очередь `createInMemoryBroadcastQueue` и админ-роут `createAdminBroadcastRoute`; роутер подключён под флаг `BROADCAST_ENABLED`, а тесты `apps/worker-main/features/broadcast/__tests__/admin-broadcast-route.test.ts` и `apps/worker-main/http/__tests__/router.test.ts` подтверждают валидацию и авторизацию.
2. Планировщик отправок.
   - **Результат:** модуль очереди (на старте — in-memory, затем опционально Cloudflare Queues) обрабатывает пачки с задержками, уважая лимиты и гарантируя идемпотентность по jobId.
   - **Проверка:** тесты симулируют массовую рассылку, проверяют обработку `429`, повторов и идемпотентность; прогресс задания сохраняется в KV.
3. Внешние действия.
   - **Внешние действия:**
     - Настроить KV-флаг `BROADCAST_ENABLED`.
     - (Опционально) создать Queue `wrangler queues create broadcast-queue` и привязать.
   - **Проверка:** команда запускает тестовую рассылку на 2–3 пользователей и подтверждает получение сообщений без ошибок в логах; проверяется возможность ручной остановки.

**Риски и предохранители:** запрет пустых сообщений; защита от дубликатов при рестарте; ограничение размера рассылки и мониторинг ошибок.

**Критерии приёмки:** рассылка отправляется, соблюдая троттлинг, при ошибках отдельные пользователи пропускаются без падения ядра.

### Майлстоун 9. Observability & Operations
**Цель:** обеспечить мониторинг, алерты и устойчивость к сбоям.

**Зависимости:** майлстоуны 1–8.

**Шаги и проверки:**
1. Логирование и трассировка.
   - **Результат:** единый логгер в `shared/` с уровнями (info/warn/error) и контекстом (requestId, userId); интеграция с `wrangler tail`.
   - **Проверка:** `npm run test -- logger` и ручная проверка логов; персональные данные маскируются.
2. Метрики и алерты.
   - **Результат:** экспорт технических метрик (ответы, ошибки, латентность) в Workers Analytics Engine или сторонний сервис; определены алерты по ключевым SLA.
   - **Проверка:** отчёт команды о появлении метрик в панели; автоматический smoke-тест подтверждает отправку метрик; алерты тестируются через понижение порога.
3. Операционные инструкции.
   - **Результат:** документы в `memory-bank/` с инструкциями по обновлению ассистента, ротации секретов, процедурам инцидентов; указаны контакты on-call и частота ревизии.
   - **Проверка:** ревью содержимого, подтверждение команды; чек-лист подписан ответственными лицами.

**Риски и предохранители:** регулярные учения по инцидентам; уведомление on-call о любых изменениях; метрики покрывают все критичные сценарии.

**Критерии приёмки:** логи и метрики доступны, документация покрывает стандартные операции.

### Майлстоун 10. Post-MVP Enhancements (опциональный backlog)
**Цель:** подготовить пространство для расширения (например, .xlsx, мультиязычность, очереди).

**Идеи и проверки:**
- Экспорт `.xlsx` через очередь и R2.
- Автономное тестирование промптов Responses.
- Сегментация пользователей для рассылок.
Каждый пункт потребует отдельной декомпозиции перед стартом.

### Финальные шаги. Внешние проверки созданного кода
**Цель:** подтвердить готовность решения к эксплуатации через независимые внешние проверки.

**Зависимости:** завершены майлстоуны 1–10.

**Шаги и проверки:**
1. Независимое код-ревью продуктовой командой.
   - **Результат:** внешний ревьюер подтверждает соответствие кода архитектурным принципам и критериям качества.
   - **Проверка:** подписанный отчёт ревьюера с перечнем замечаний и статусом их устранения хранится в `memory-bank/reviews/`.
   - **Внешние действия:** пригласить ревьюера, предоставить доступ к репозиторию и журналы прогресса.
2. Внешнее тестирование на предпроде.
   - **Результат:** QA-команда проводит сценарное тестирование бота на стенде, фиксируя результаты в общем отчёте.
   - **Проверка:** чек-лист тестов с отметками «пройдено/не пройдено» и ссылками на логи хранится в `memory-bank/tests/`.
   - **Внешние действия:** подготовить стенд, предоставить инструкции по тестированию и сценарии проверок.
3. Аудит безопасности и соответствия требованиям.
   - **Результат:** специалисты по безопасности подтверждают отсутствие критичных уязвимостей и корректную работу с секретами.
   - **Проверка:** акт аудита и список рекомендаций сохранён в `memory-bank/security/`, критичные пункты закрыты.
   - **Внешние действия:** организовать аудит, предоставить доступ к конфигурации секретов, ответить на вопросы аудиторов.

**Риски и предохранители:** задержка ревью может сдвинуть релиз; фиксировать в журнале все внешние взаимодействия и SLA; при выявлении критичных дефектов возвращаться к соответствующему майлстоуну для исправлений.

**Критерии приёмки:** все внешние проверки завершены, отчёты сохранены, замечания устранены или зафиксированы с планом работ.

## Исправления после проваленных проверок
- [x] **ИСПРАВЛЕНИЕ:** восстановить проверку типов `npx tsc --noEmit` после ошибок TS2322/TS2339/TS2304/TS2345 (2025-11-01) —
  перевести `tsconfig.json` на `module: "NodeNext"` с `DOM`-библиотеками, экспортировать `D1Database`, усилить сигнатуры моков в
  тестах и скорректировать проверки Telegram webhook; подтверждено успешным запуском `npx tsc --noEmit` (лог
  `logs/tsc-2025-11-01-success.txt`).

## Журнал прогресса
- 2025-11-01: Исправлены несоответствия типов в адаптерах/тестах (`tsconfig` приведён к `NodeNext`, моки переопределены, webhook-
  тесты адаптированы); `npx tsc --noEmit` завершился успешно, лог сохранён в `logs/tsc-2025-11-01-success.txt`.
- 2025-11-02: Проверка типов `npx tsc --noEmit` завершилась ошибкой TS5110 из-за несоответствия `module` и `moduleResolution`; лог сохранён в `logs/tsc-2025-11-01.txt`, задача-торможение по проверкам остаётся активной до устранения.
- 2025-11-01: Прогнан `npm test` для подтверждения стабильности активной связки (М1, проверки активного стека); лог сохранён в `logs/test-2025-11-01.txt`, задача-торможение по проверкам остаётся открытой до полного комплекта запусков.
- 2025-10-28: Закрыт шаг М4.Ш1 — подтверждена миграция адаптера Responses, RoadMap обновлена статусом, сверены тесты `openai-responses.test.ts`.
- 2025-10-29: Закрыт шаг М8.Ш1 — реализованы очередь рассылок и админ-роут под флагом `BROADCAST_ENABLED`, добавлены тесты `admin-broadcast-route.test.ts` и обновлён HTTP-роутер.
- 2025-10-27: Адаптер OpenAI Responses мигрирован на `OPENAI_MODEL`/`OPENAI_PROMPT_ID`, обновлён маршрут `envz`, добавлены тесты `previous_response_id`.
- 2025-10-23: Инициализирована дорожная карта и создан каталог памяти (этап текущей сессии).
- 2025-10-23: Обновлена структура и правила дорожной карты.
- 2025-10-23: Сформирована детальная дорожная карта с майлстоунами 1–9 (до архитектурного обновления).
- 2025-10-24: Дорожная карта уточнена: устранены дубликаты, уточнены проверки и результаты шагов.
- 2025-10-24: Проведён критический анализ рисков, усилены проверки и предохранители по всем майлстоунам.
- 2025-10-24: Добавлены процедуры синхронизации ветки и проверки конфликтов перед PR.
- 2025-10-24: Реализован контур `DialogEngine`, определены контракты портов, подготовлены юнит-тесты (ожидают установки зависимостей npm).
- 2025-10-24: Подготовлен Telegram-парсер вебхука, команды `/admin*` обрабатываются до ядра, покрыто юнит-тестами `http/telegram-webhook`.
- 2025-10-24: Реализован адаптер Telegram messaging с ретраями и модульными тестами `apps/worker-main/adapters/telegram/__tests__/messaging.test.ts`.
- 2025-10-24: Настроен менеджер typing-индикации, роутер вызывает его перед ядром, добавлены тесты `apps/worker-main/http/__tests__/typing-indicator.test.ts`.
- 2025-10-24: Добавлен адаптер OpenAI Responses с таймаутами, ретраями и фильтрацией управляющих символов; написаны тесты `apps/worker-main/adapters/openai-responses/__tests__/openai-responses.test.ts`.
- 2025-10-24: Подготовлена стартовая миграция D1 `0001_init_dialog_tables.sql` с таблицами пользователей и сообщений.
- 2025-10-24: Реализован адаптер `createD1StorageAdapter` для Cloudflare D1 с модульными тестами `apps/worker-main/adapters/d1-storage/__tests__/d1-storage.test.ts`.
- 2025-10-24: Настроен KV-флаг `LIMITS_ENABLED` для гибкого отключения лимитов, добавлены обёртки и тесты `apps/worker-main/features/limits`.
- 2025-10-24: Добавлен KV-адаптер лимитов `createKvRateLimitAdapter` с TTL 24 часа и юнит-тестами `apps/worker-main/adapters/kv-rate-limit/__tests__/kv-rate-limit.test.ts`.
- 2025-10-24: Реализован нотификатор лимита `createRateLimitNotifier`, HTTP-роутер рассылает предупреждения и покрыт тестами `apps/worker-main/features/limits/__tests__/rate-limit-notifier.test.ts`, `apps/worker-main/http/__tests__/router.test.ts`.
- 2025-10-24: Добавлен админ-роут `/admin/export`, реализован потоковый CSV-генератор, обновлены тесты HTTP и экспорт-фичи.
- 2025-10-24: Добавлены финальные внешние проверки и обновлён быстрый протокол действий.
- 2025-10-26: Дорожная карта перестроена под Responses-only: добавлен майлстоун 1, перенумерованы шаги 2–10, зафиксированы проверки и задачи-торможения.
- 2025-10-26: Подготовлен план внешней проверки `/admin/export` для запуска после деплоя.
- 2025-10-27: Сформирован план ревизии модулей для Responses-only (М1.Ш3); обновлены `memory-bank/infrastructure.md`, `memory-bank/stable-builds.md`, незакрытые проверки отмечены блокером до выполнения адаптаций.
- 2025-10-27: Завершено обновление быстрых инструкций и памяток под Responses-only, закрыт шаг М1.Ш4 (проверка требований `OPENAI_MODEL`/`OPENAI_PROMPT_ID`, фиксация отказа от `assistantId`).

## Быстрый протокол действий
1. Проверить ветку и статус репозитория.
2. Ознакомиться с `RoadMap.md`, памятками в `memory-bank/` и актуальным списком проверок майлстоуна 1, подтвердить отсутствие новых зависимостей от `assistantId` и учёт требований к `OPENAI_MODEL`/`OPENAI_PROMPT_ID` (значения триммятся, `pmpt_` проверяется, переменные валидируются).
3. Составить микроплан и выполнить изменения ограниченной партией, указав в нём количество оставшихся проверок до завершения текущего шага.
4. **ПРОВЕРКИ ОБЯЗАТЕЛЬНЫ.** После каждой партии запускать проверки, просматривать изменения, обновлять журнал и памятки, фиксируя прогресс и оставшиеся проверки в отчёте.
5. Фиксировать в журнале прогресса рядом с временем шага его номер, номер текущего майлстоуна и ссылку на соответствующий список проверок.
6. Если требуется внешняя проверка созданного кода, то при команде «Следуй дорожной карте» создавай задачу с названием «ПРОВЕРКА», добавляй в Журнал прогресса строку «Переход к проверке» и указывай в отчёте фразу «ПРОВЕСТИ ПРОВЕРКУ» с инструкциями по проверке ниже.
7. При обнаружении невыполненной критичной проверки предыдущего шага немедленно добавляй в `memory-bank/` памятку «ЗАДАЧА-ТОРМОЖЕНИЕ: требуется проверка <описание>» (если уже есть «ЗАДАЧА-ТОРМОЖЕНИЕ: проверки не закрыты» — обновляй её содержимое) и останавливай продвижение по RoadMap до её закрытия.
8. Убедиться в чистоте истории: `git status`, `git diff --check`, разрешение конфликтов фиксируется в журнале.
9. Закоммитить изменения, подготовить PR через `make_pr`.
10. Отчёт о выполнении задачи всегда предоставляй на русском языке.
11. В отчёте указывай прогресс-бар с процентом пройденного пути, целью ближайшего майлстоуна и количеством задач до него, а также количеством шагов до ближайшей проверки.
