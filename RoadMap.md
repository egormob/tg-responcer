# RoadMap

## Контекст и цели
- Репозиторий `tg-responcer` управляется по базовому протоколу из `Protocol.md`.
- Цель дорожной карты — поддерживать единый источник истины о состоянии проекта, шагах разработки и правилах операционной системы.
- **Цель проекта:** собрать Telegram-бота на OpenAI Responses через Cloudflare Worker с ядром диалогового контура и модульными апгрейдами. Бот должен вести диалог с памятью (системный промпт/файлы/инструменты управляются в Responses), сохранять историю в БД с возможностью выгрузки CSV/Excel, поддерживать ручные рассылки пользователям, ограничивать количество ответов и показывать `typing…` в ожидании ответа.

## Принципы работы
1. Следовать протоколу: поддерживать артефакты `RoadMap.md` и `memory-bank/`, хранить логи/снапшоты вне git.
2. Работать партиями до ≈150 файлов, контролировать `git diff --stat`, выполнять проверки после каждой партии.
3. Каждый подпункт в дорожной карте завершать отдельным коммитом и фиксировать прогресс здесь.
4. Поддерживать линейность истории ветки `work`, избегая расходящихся коммитов.
5. Перед началом задачи сверяться с архитектурой, рисками и актуальной картиной системы.

## Структура задач

### Майлстоун 1: Операционная система управления проектом
**Описание:** внедрить артефакты RoadMap и memory-bank, определить процедуры ведения проекта.

**Шаги:**
1. Создать `RoadMap.md` с целями, принципами и последовательностью работы.
2. Создать каталог `memory-bank/` для памяток и вспомогательных документов, добавить файл-заглушку.
3. Согласовать процедуру проверки рисков и поддержания линейной истории.

**Критерии приёмки:**
- Файл `RoadMap.md` содержит актуальные цели, принципы, структуру задач и журнал прогресса.
- Каталог `memory-bank/` присутствует в репозитории и готов к наполнению памятками.
- Отражены проверки рисков и контроль линейности коммитов.

**Риски и меры:**
- *Риск:* несогласованность между Protocol и RoadMap. *Мера:* проверять изменения с Protocol перед обновлениями.
- *Риск:* забыть фиксировать прогресс. *Мера:* обновлять раздел «Журнал» по завершении каждого шага.
- *Риск:* нарушение линейности ветки. *Мера:* проверять `git status -sb` и журнал перед коммитами/мерджами.

**Статус:** завершено 2025-10-23.

### Структура

**Цель:** устойчивый диалоговый контур с возможностью подключать апгрейды (экспорт, рассылка, лимиты) без изменений и рисков для базы.

**Слои и их роли:**
- **Ядро (`core/`)** — последовательность шагов диалога (лимит → запись → ответ ИИ → запись → отправка). Никаких SDK/HTTP. Статус: **FROZEN**.
- **Порты (`ports/`)** — четыре стабильных интерфейса: `MessagingPort` (`sendTyping`, `sendText`), `AiPort` (`reply({ userId, text, context }) → { text }`), `StoragePort` (`saveUser`, `appendMessage`, `getRecentMessages`), `RateLimitPort` (`checkAndInc → "ok" | "limit"`).
- **Адаптеры (`adapters/*`)** — реализации портов (Telegram, OpenAI Responses, D1, KV и т.п.).
- **NOOP-адаптеры (`adapters-noop/*`)** — безопасные заглушки для каждого порта по умолчанию.
- **Композиция (`composition/`)** — сборка адаптеров, регистрация фич и чтение KV-флагов.
- **HTTP (`http/`)** — только роутинг: `POST /webhook/:secret` (включая обработку команд/админа до ядра), `GET /healthz`, `/admin/*` (роуты фич).
- **Фичи (`features/*`)** — апгрейды как отдельные модули (экспорт CSV, рассылка, лимиты). Подключаются через `composition/register-features.ts` в `try/catch`; при сбое ядро остаётся рабочим.

**Инварианты Responses:**
- Промпты/файлы/инструменты управляются в OpenAI Responses, воркер использует `OPENAI_ASSISTANT_ID` и обычный REST-запрос `POST /v1/responses` без стриминга.
- При ответе показываем `typing…`, затем отправляем финальное сообщение.
- Контекст для модели — короткий хвост из `StoragePort.getRecentMessages`.

**Хранилища и флаги:**
- Диалоги и пользователи — Cloudflare D1 (Paid до 10 ГБ, Free до 500 МБ).
- Лимиты и фич-флаги — Cloudflare KV (`STREAMING`, `BROADCAST`, `EXPORT_ENABLED`, `LIMITS_ENABLED` и др.).
- Админ-доступ: `/admin/*` через заголовок `X-Admin-Token`, чат-команды — whitelist `ADMIN_IDS`.

**Технические предохранители:** `CODEOWNERS` на `/core` и `/ports`, CI-гард, eslint-правила против сквозных импортов.

### Правила

1. **FROZEN CORE.** `core/` меняем только с bump `core/VERSION` и ревью владельца.
2. **Стабильные порты.** Сигнатуры в `ports/` неизменны без версионирования и ревью.
3. **Только через порты.** Ядро не импортирует SDK, HTTP или биндинги Cloudflare.
4. **Команды до ядра.** `/admin`, `/broadcast` и служебные команды обрабатываются в `http/`, а не в `DialogEngine`.
5. **Фичи не трогают ядро.** Новые функции живут в `features/*` и подключаются через `composition/` под KV-флаги.
6. **NOOP по умолчанию.** При отсутствии адаптера/фичи используется заглушка, диалог остаётся работоспособным.
7. **Без промптов в коде.** Настройка ассистента — только в Responses (`OPENAI_ASSISTANT_ID`).
8. **Админ-охранник.** `/admin/*` требует `X-Admin-Token`; чат-команды доступны только `ADMIN_IDS`.
9. **Мягкая деградация.** Внешние вызовы защищены `try/catch` и таймаутами, ошибки логируем без остановки ядра.
10. **Троттлинг и лимиты.**
    - Применяется к массовым отправкам (рассылки, циклы). Обычные ответы ядра не троттлим.
    - Лимиты Telegram: ≤30 сообщений/сек глобально, ≤1 сообщение/сек в личный чат, ≤20 сообщений/мин в группы/каналы.
    - При `429 Too Many Requests` читаем `retry_after`, ждём указанное время, используем экспоненциальную задержку с джиттером, не более трёх ретраев, затем логируем и пропускаем адресата.
    - Отправляем батчами с паузами, порядок внутри батча не критичен.
    - При росте объёмов выносим рассылки в Cloudflare Queues (ретраи, батч-обработка) без изменений ядра.
11. **Тесты-сторожа.** Контракты портов, смоук `/webhook` с моками, проверка отключённых фич.
12. **Guardrails в репо.** `CODEOWNERS`, CI-гард и eslint обеспечивают замороженное ядро и корректные импорты.
13. **Retain & Rotate.** Политика хранения диалогов, крупные выгрузки — CSV с пагинацией или очередями.
14. **Флаги — источник правды.** Подключение/отключение фич происходит через KV и `composition/`.

## Журнал прогресса
- 2025-10-23: Инициализирована дорожная карта и создан каталог памяти (этап текущей сессии).

## Быстрый протокол действий
1. Проверить ветку и статус репозитория.
2. Ознакомиться с `RoadMap.md` и памятками в `memory-bank/`.
3. Составить микроплан и выполнить изменения ограниченной партией.
4. Запустить проверки, просмотреть изменения, обновить журнал и памятки.
5. Закоммитить изменения, подготовить PR через `make_pr`.
