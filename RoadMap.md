# RoadMap

## Контекст и цели
- Репозиторий `tg-responcer` управляется по базовому протоколу из `Protocol.md`.
- Цель дорожной карты — поддерживать единый источник истины о состоянии проекта, шагах разработки и правилах операционной системы.
- **Цель проекта:** собрать Telegram-бота на OpenAI Responses через Cloudflare Worker с ядром диалогового контура и модульными апгрейдами. Бот должен вести диалог с памятью (системный промпт/файлы/инструменты управляются в Responses), сохранять историю в БД с возможностью выгрузки CSV/Excel, поддерживать ручные рассылки пользователям, ограничивать количество ответов и показывать `typing…` в ожидании ответа.

## Принципы работы
1. Следовать протоколу: поддерживать артефакты `RoadMap.md` и `memory-bank/`, хранить логи/снапшоты вне git.
2. Работать партиями до ≈150 файлов, контролировать `git diff --stat`, выполнять проверки после каждой партии.
3. Каждый подпункт в дорожной карте завершать отдельным коммитом и фиксировать прогресс здесь.
4. Поддерживать линейность истории ветки `work`, избегая расходящихся коммитов.
5. Перед началом задачи сверяться с архитектурой, рисками и актуальной картиной системы.

## Структура задач

### Майлстоун 1: Операционная система управления проектом
**Описание:** внедрить артефакты RoadMap и memory-bank, определить процедуры ведения проекта.

**Шаги:**
1. Создать `RoadMap.md` с целями, принципами и последовательностью работы.
2. Создать каталог `memory-bank/` для памяток и вспомогательных документов, добавить файл-заглушку.
3. Согласовать процедуру проверки рисков и поддержания линейной истории.

**Критерии приёмки:**
- Файл `RoadMap.md` содержит актуальные цели, принципы, структуру задач и журнал прогресса.
- Каталог `memory-bank/` присутствует в репозитории и готов к наполнению памятками.
- Отражены проверки рисков и контроль линейности коммитов.

**Риски и меры:**
- *Риск:* несогласованность между Protocol и RoadMap. *Мера:* проверять изменения с Protocol перед обновлениями.
- *Риск:* забыть фиксировать прогресс. *Мера:* обновлять раздел «Журнал» по завершении каждого шага.
- *Риск:* нарушение линейности ветки. *Мера:* проверять `git status -sb` и журнал перед коммитами/мерджами.

**Статус:** завершено 2025-10-23.

### Структура

**Подход:** изолированное «ядро» диалога, порты и адаптеры, композиция и внешние фичи, соответствующие принципу «замороженного» ядра и подключаемых модулей.

**Директории и ответственность:**
- `apps/worker-main/http/` — только HTTP-роутеры (`/webhook`, `/healthz`, `/admin/*`), команды и админ-обработка до ядра.
- `apps/worker-main/core/` — FROZEN CORE: `DialogEngine.ts`, контракты и README о правилах изменений, версия ядра.
- `apps/worker-main/ports/` — FROZEN API: интерфейсы `MessagingPort`, `AiPort`, `StoragePort`, `RateLimitPort`.
- `apps/worker-main/adapters/` — реализации портов (Telegram, OpenAI Responses, хранилища D1/KV и др.).
- `apps/worker-main/adapters-noop/` — заглушки для каждого порта, используемые по умолчанию.
- `apps/worker-main/composition/` — композиция адаптеров и регистрация фич; единственная точка включения модулей и чтения фич-флагов.
- `apps/worker-main/features/` — независимые апгрейды (экспорт CSV, рассылка, лимиты) с собственными HTTP-роутами/мидлварами.
- `apps/worker-main/shared/` — общие утилиты, типы, валидация и логирование.
- Технические предохранители: `CODEOWNERS` на `/core` и `/ports`, CI-гард, eslint-правила для ограничения импортов.

**Принципы расширения:**
- Ядро не меняем без bump версии; фичи подключаем через композицию и порты.
- Адаптеры и фичи используют только порты и shared-утилиты.
- Фичи регистрируются через `composition/register-features.ts` в `try/catch`; при сбое ядро продолжает работу.
- Фичи управляются флагами (например, KV) для включения/отключения без правок ядра.

## Журнал прогресса
- 2025-10-23: Инициализирована дорожная карта и создан каталог памяти (этап текущей сессии).

## Быстрый протокол действий
1. Проверить ветку и статус репозитория.
2. Ознакомиться с `RoadMap.md` и памятками в `memory-bank/`.
3. Составить микроплан и выполнить изменения ограниченной партией.
4. Запустить проверки, просмотреть изменения, обновить журнал и памятки.
5. Закоммитить изменения, подготовить PR через `make_pr`.
